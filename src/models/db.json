{
  "title": "JavaScript Interview Questions & Answers",
  "description": "Click ‚≠ê if you like the project and follow @SudheerJonna for more updates. Coding questions available here. Check DataStructures and Algorithms for DSA related questions and ECMAScript for all ES features.",
  "sponsors": [
    {
      "name": "GreatFrontEnd",
      "description": "üí° Nail JavaScript interviews with questions and solutions from ex-interviewers! Try GreatFrontEnd ‚Üí üí°"
    },
    {
      "name": "FrontEndLead",
      "description": "üöÄ Ace Javascript interview questions with solutions from FAANG+ companies! Try FrontendLead ‚Üí üöÄ"
    },
    {
      "name": "ZTM",
      "description": "1. Take this JavaScript Projects course to go from a JS beginner to confidently building your own projects\n2. Take this coding interview bootcamp if you're serious about getting hired and don't have a CS degree\n3. Take this Advanced JavaScript Course to learn advanced JS concepts and become a top JS developer"
    }
  ],
  "questions": [
    {
      "id": 1,
      "question": "What are the possible ways to create objects in JavaScript",
      "answer": "There are many ways to create objects in javascript as mentioned below:\n\n**Object literal syntax:**\n\nThe object literal syntax (or object initializer), is a comma-separated set of name-value pairs wrapped in curly braces.\n\n```javascript\nvar object = {\n  name: \"Sudheer\",\n  age: 34,\n};\n```\n\nObject literal property values can be of any data type, including array, function, and nested object.\n\nNote: This is one of the easiest ways to create an object and it's most commonly used for creating simple, ad-hoc objects.\n\n**Object constructor:**\n\nThe simplest way to create an empty object is using the Object constructor. Currently this approach is not recommended.\n\n```javascript\nvar object = new Object();\n```\n\nThe Object() is a built-in constructor function so \"new\" keyword is not required for creating plain objects. The above code snippet can be re-written as:\n\n```javascript\nvar object = Object();\n```\n\nHowever, Object() can be used to either create a plain object or convert a given value into its corresponding object wrapper, whereas new Object() is specifically used to explicitly create a new object instance.\n\n**Object's create method:**\n\nThe create method of Object is used to create a new object by passing the specified prototype object and properties as arguments, i.e., this pattern is helpful to create new objects based on existing objects. In other words, this is useful for setting up prototypal inheritance. The second argument is optional and it is used to create properties on a newly created object.\n\nThe following code creates a new empty object whose prototype is null.\n\n```javascript\nvar object = Object.create(null);\n```\n\nThe following example creates an object along with additional new properties.\n\n```javascript\nlet vehicle = {\n  wheels: \"4\",\n  fuelType: \"Gasoline\",\n  color: \"Green\",\n};\nlet carProps = {\n  type: {\n    value: \"Volkswagen\",\n  },\n  model: {\n    value: \"Golf\",\n  },\n};\n\nvar car = Object.create(vehicle, carProps);\nconsole.log(car);\n```\n\n**Function constructor:**\n\nIn this approach, create any function and apply the new operator to create object instances. This was the main way to do constructor-based OOP before ES6 classes.\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n  this.age = 21;\n}\nvar object = new Person(\"Sudheer\");\n```\n\n**Function constructor with prototype:**\n\nThis is similar to function constructor but it uses prototype for their properties and methods. Using prototype means you're sharing methods/properties across instances, which saves memory and improve performance.\n\n```javascript\nfunction Person() {}\nPerson.prototype.name = \"Sudheer\";\nvar object = new Person();\n```\n\nThis is equivalent to creating an instance with Object.create method with a function prototype and then calling that function with an instance and parameters as arguments.\n\n```javascript\nfunction func(x, y, z) {\n this.x = x;\n this.y = y;\n this.z = z;\n}\n\nvar instance = new func(1, 2, 3);\n// (OR)\n\nfunction func(x, y, z) {\n   this.x = x;\n   this.y = y;\n   this.z = z;\n}\n// Create a new instance using function prototype.\nvar newInstance = Object.create(func.prototype)\n\n// Call the function\nvar result = func.call(newInstance, 1, 2, 3),\n\n// If the result is a non-null object then use it otherwise just use the new instance.\nconsole.log(result && typeof result === 'object' ? result : newInstance);\n```\n\n**Object's assign method:**\n\nThe Object.assign method is used to copy all the properties from one or more source objects and stores them into a target object. This is mainly used for cloning and merging\n\nThe following code creates a new staff object by copying properties of his working company and the car he owns.\n\n```javascript\nconst orgObject = { company: \"XYZ Corp\" };\nconst carObject = { name: \"Toyota\" };\nconst staff = Object.assign({}, orgObject, carObject);\n```\n\n**ES6 Class syntax:**\n\nES6 introduces class feature to create objects. This is syntactic sugar over the prototype-based system.\n\n```javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nvar object = new Person(\"Sudheer\");\n```\n\n**Singleton pattern:**\n\nA Singleton is an object which can only be instantiated one time. Repeated calls to its constructor return the same instance. This way one can ensure that they don't accidentally create multiple instances.\n\nSingleton with Closure (Classic JS Pattern)\n\n```javascript\nconst Singleton = (function () {\nlet instance;\n\nfunction createInstance() {\n  return { name: \"Sudheer\" };\n}\n\nreturn {\n  getInstance: function () {\n    if (!instance) {\n      instance = createInstance();\n    }\n    return instance;\n  }\n};\n})();\n\n// Usage\nconst obj1 = Singleton.getInstance();\nconst obj2 = Singleton.getInstance();\n\nconsole.log(obj1 === obj2); // true\n```\n\nIn modern JavaScript applications, singletons are commonly implemented using ES6 modules for their built-in caching behavior, or closures for encapsulated state management."
    },
    {
      "id": 2,
      "question": "What is a prototype chain",
      "answer": "The prototype chain is a core concept in JavaScript's inheritance model. It allows objects to inherit properties and methods from other objects. When you try to access a property or method on an object, JavaScript first looks for it on that object itself. If it's not found, the engine looks up the object's internal [[Prototype]] reference (accessible via Object.getPrototypeOf(obj) or the deprecated __proto__ property) and continues searching up the chain until it finds the property or reaches the end (usually null).\n\nFor objects created via constructor functions, the prototype chain starts with the instance, then refers to the constructor's .prototype object, and continues from there. For example:\n\n```javascript\nfunction Person() {}\nconst person1 = new Person();\n\nconsole.log(Object.getPrototypeOf(person1) === Person.prototype); // true\n```\n\nThis mechanism allows for property and method sharing among objects, enabling code reuse and a form of inheritance.\n\n**Summary:**\n\n- The prototype chain enables inheritance in JavaScript.\n- If a property isn't found on an object, JavaScript looks up its prototype chain.\n- The prototype of an object instance can be accessed with Object.getPrototypeOf(obj) or __proto__.\n- The prototype of a constructor function is available via Constructor.prototype.\n- The chain ends when the prototype is null."
    },
    {
      "id": 3,
      "question": "What is the Difference Between call, apply, and bind",
      "answer": "In JavaScript, call, apply, and bind are methods that allow you to control the context (this value) in which a function is executed. While their purposes are similar, they differ in how they handle arguments and when the function is invoked.\n\n**call**\n\nDescription: The call() method invokes a function immediately, allowing you to specify the value of this and pass arguments individually (comma-separated).\n\nSyntax:\n```javascript\nfunc.call(thisArg, arg1, arg2, ...)\n```\n\nExample:\n```javascript\nvar employee1 = { firstName: \"John\", lastName: \"Rodson\" };\nvar employee2 = { firstName: \"Jimmy\", lastName: \"Baily\" };\n\nfunction invite(greeting1, greeting2) {\n  console.log(\n    greeting1 + \" \" + this.firstName + \" \" + this.lastName + \", \" + greeting2\n  );\n}\n\ninvite.call(employee1, \"Hello\", \"How are you?\"); // Hello John Rodson, How are you?\ninvite.call(employee2, \"Hello\", \"How are you?\"); // Hello Jimmy Baily, How are you?\n```\n\n**apply**\n\nDescription: The apply() method is similar to call(), but it takes the function arguments as an array (or array-like object) instead of individual arguments.\n\nSyntax:\n```javascript\nfunc.apply(thisArg, [argsArray])\n```\n\nExample:\n```javascript\nvar employee1 = { firstName: \"John\", lastName: \"Rodson\" };\nvar employee2 = { firstName: \"Jimmy\", lastName: \"Baily\" };\n\nfunction invite(greeting1, greeting2) {\n  console.log(\n    greeting1 + \" \" + this.firstName + \" \" + this.lastName + \", \" + greeting2\n  );\n}\n\ninvite.apply(employee1, [\"Hello\", \"How are you?\"]); // Hello John Rodson, How are you?\ninvite.apply(employee2, [\"Hello\", \"How are you?\"]); // Hello Jimmy Baily, How are you?\n```\n\n**bind**\n\nDescription: The bind() method creates a new function with a specific this value and, optionally, preset initial arguments. Unlike call and apply, bind does not immediately invoke the function; instead, it returns a new function that you can call later.\n\nSyntax:\n```javascript\nvar boundFunc = func.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\nExample:\n```javascript\nvar employee1 = { firstName: \"John\", lastName: \"Rodson\" };\nvar employee2 = { firstName: \"Jimmy\", lastName: \"Baily\" };\n\nfunction invite(greeting1, greeting2) {\n  console.log(\n    greeting1 + \" \" + this.firstName + \" \" + this.lastName + \", \" + greeting2\n  );\n}\n\nvar inviteEmployee1 = invite.bind(employee1);\nvar inviteEmployee2 = invite.bind(employee2);\n\ninviteEmployee1(\"Hello\", \"How are you?\"); // Hello John Rodson, How are you?\ninviteEmployee2(\"Hello\", \"How are you?\"); // Hello Jimmy Baily, How are you?\n```\n\n**Summary:**\n\n| Method | Invokes Function Immediately? | How Arguments Are Passed | Returns |\n|--------|------------------------------|-------------------------|----------|\n| call | Yes | Comma-separated list | Function's result |\n| apply | Yes | Array or array-like object | Function's result |\n| bind | No | (Optional) preset, then rest | New function |\n\n**Key Points:**\n- call and apply are almost interchangeable; both invoke the function immediately, but differ in how arguments are passed.\n- Tip: \"Call is for Comma-separated, Apply is for Array.\"\n- bind does not execute the function immediately. Instead, it creates a new function with the specified this value and optional arguments, which can be called later.\n- Use call or apply when you want to immediately invoke a function with a specific this context. Use bind when you want to create a new function with a specific this context to be invoked later."
    },
    {
      "id": 4,
      "question": "What is JSON and its common operations",
      "answer": "JSON (JavaScript Object Notation) is a lightweight, text-based data format that uses JavaScript object syntax for structuring data. It was popularized by Douglas Crockford and is widely used for transmitting data between a server and a client in web applications. JSON files typically have a .json extension and use the MIME type application/json.\n\n**Common Operations with JSON:**\n\n**1. Parsing:** Transforming a JSON-formatted string into a native JavaScript object.\n```javascript\nconst obj = JSON.parse(jsonString);\n```\n\nExample:\n```javascript\nconst jsonString = '{\"name\":\"John\",\"age\":30}';\nconst obj = JSON.parse(jsonString);  // { name: \"John\", age: 30 }\n```\n\n**2. Stringification:** Converting a JavaScript object into a JSON-formatted string, commonly used for data transmission or storage.\n```javascript\nconst jsonString = JSON.stringify(object);\n```\n\nExample:\n```javascript\nconst obj = { name: \"Jane\", age: 25 };\nconst jsonString = JSON.stringify(obj);  // '{\"name\":\"Jane\",\"age\":25}'\n```"
    },
    {
      "id": 5,
      "question": "What is the purpose of the array slice method",
      "answer": "The slice() method in JavaScript is used to extract a section of an array, returning a new array containing the selected elements. It does not modify the original array. The method takes two arguments:\n\n- **start:** The index at which extraction begins (inclusive).\n- **end (optional):** The index before which to end extraction (exclusive). If omitted, extraction continues to the end of the array.\n\nYou can also use negative indices, which count from the end of the array.\n\n**Examples:**\n```javascript\nlet arrayIntegers = [1, 2, 3, 4, 5];\n\nlet arrayIntegers1 = arrayIntegers.slice(0, 2);    // [1, 2]\nlet arrayIntegers2 = arrayIntegers.slice(2, 3);    // [3]\nlet arrayIntegers3 = arrayIntegers.slice(4);       // [5]\nlet arrayIntegers4 = arrayIntegers.slice(-3, -1);  // [3, 4]\n```\n\n**Note:**\nThe slice() method does not mutate (change) the original array; instead, it returns a new array containing the extracted elements."
    },
    {
      "id": 6,
      "question": "What is the purpose of the array splice method",
      "answer": "The splice() method in JavaScript is used to add, remove, or replace elements within an array. Unlike slice(), which creates a shallow copy and does not alter the original array, splice() modifies the original array in place and returns an array containing the removed elements.\n\n**Syntax:**\n```javascript\narray.splice(start, deleteCount, item1, item2, ...)\n```\n\n- **start:** The index at which to start changing the array.\n- **deleteCount:** (Optional) The number of elements to remove from the array. If omitted, all elements from the start index to the end of the array will be removed.\n- **item1, item2, ...:** (Optional) Elements to add to the array, starting at the start position.\n\n**Examples:**\n```javascript\nlet arrayIntegersOriginal1 = [1, 2, 3, 4, 5];\nlet arrayIntegersOriginal2 = [1, 2, 3, 4, 5];\nlet arrayIntegersOriginal3 = [1, 2, 3, 4, 5];\n\n// Remove the first two elements\nlet arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); \n// arrayIntegers1: [1, 2]\n// arrayIntegersOriginal1 (after): [3, 4, 5]\n\n// Remove all elements from index 3 onwards\nlet arrayIntegers2 = arrayIntegersOriginal2.splice(3);     \n// arrayIntegers2: [4, 5]\n// arrayIntegersOriginal2 (after): [1, 2, 3]\n\n// Remove 1 element at index 3, then insert \"a\", \"b\", \"c\" at that position\nlet arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, \"a\", \"b\", \"c\"); \n// arrayIntegers3: [4]\n// arrayIntegersOriginal3 (after): [1, 2, 3, \"a\", \"b\", \"c\", 5]\n```\n\n**Note:**\n- The splice() method modifies the original array.\n- It returns an array containing the elements that were removed (if any).\n- You can use it both to remove and insert elements in a single operation."
    },
    {
      "id": 7,
      "question": "What is the difference between slice and splice",
      "answer": "Here are the key differences between slice() and splice() methods in JavaScript arrays:\n\n| Feature | slice() | splice() |\n|---------|---------|----------|\n| **Array Modification** | Does not modify the original array (immutable) | Modifies the original array (mutable) |\n| **Return Value** | Returns a shallow copy (subset) of selected elements | Returns an array of the removed elements |\n| **Purpose** | Used to extract elements from an array | Used to add, remove, or replace elements in an array |\n| **Syntax** | `array.slice(start, end)` | `array.splice(start, deleteCount, ...items)` |\n\n**Summary:**\n\n- Use **slice()** when you want to copy or extract elements without altering the original array.\n- Use **splice()** when you need to add, remove, or replace elements and want to change the original array."
    },
    {
      "id": 8,
      "question": "How do you compare Object and Map",
      "answer": "Objects and Maps both allow you to associate keys with values, retrieve those values, delete keys, and check if a key exists. Historically, Objects have been used as Maps, but there are several key differences that make Map a better choice in certain scenarios:\n\n| Feature | Object | Map |\n|---------|---------|-----|\n| **Key Types** | Only strings and symbols are valid keys | Any value can be used as a key (objects, functions, primitives) |\n| **Key Order** | Keys are unordered (in practice, insertion order is mostly preserved for string keys, but not guaranteed) | Keys are ordered by insertion; iteration follows insertion order |\n| **Size Property** | No built-in way to get the number of keys; must use `Object.keys(obj).length` | Use the `.size` property for the number of entries |\n| **Iterability** | Not directly iterable; must use `Object.keys`, `Object.values`, or `Object.entries` | Directly iterable with `for...of`, `.keys()`, `.values()`, `.entries()` |\n| **Prototype** | Has a prototype chain; may have default properties that can collide with custom keys (can be avoided with `Object.create(null)`) | Does not have a prototype, so there are no default keys |\n| **Performance** | May be less efficient for frequent additions/removals | Optimized for frequent additions and deletions |\n| **Serialization** | Can be easily serialized to JSON | Cannot be directly serialized to JSON |"
    },
    {
      "id": 9,
      "question": "What is the difference between == and === operators",
      "answer": "JavaScript provides two types of equality operators:\n\n- **Loose equality (==, !=):** Performs type conversion if the types differ, comparing values after converting them to a common type.\n- **Strict equality (===, !==):** Compares both value and type, without any type conversion.\n\n**Strict Equality (===)**\n\n- Two strings are strictly equal if they have exactly the same sequence of characters and length.\n- Two numbers are strictly equal if they have the same numeric value.\n- Special cases:\n  - `NaN === NaN` is `false`\n  - `+0 === -0` is `true`\n- Two booleans are strictly equal if both are true or both are false.\n- Two objects are strictly equal if they refer to the same object in memory.\n- `null` and `undefined` are not strictly equal.\n\n**Loose Equality (==)**\n\n- Converts operands to the same type before making the comparison.\n- `null == undefined` is `true`.\n- `\"1\" == 1` is `true` because the string is converted to a number.\n- `0 == false` is `true` because false is converted to 0.\n\n**Examples:**\n```javascript\n0 == false            // true      (loose equality, type coercion)\n0 === false           // false     (strict equality, different types)\n1 == \"1\"              // true      (string converted to number)\n1 === \"1\"             // false     (different types)\nnull == undefined     // true      (special case)\nnull === undefined    // false     (different types)\n'0' == false          // true      ('0' is converted to 0)\n'0' === false         // false     (different types)\nNaN == NaN            // false     (NaN is never equal to itself)\nNaN === NaN           // false\n[] == []              // false     (different array objects)\n[] === []             // false\n{} == {}              // false     (different object references)\n{} === {}             // false\n```"
    },
    {
      "id": 10,
      "question": "What are lambda expressions or arrow functions",
      "answer": "Arrow functions (also known as \"lambda expressions\") provide a concise syntax for writing function expressions in JavaScript. Introduced in ES6, arrow functions are often shorter and more readable, especially for simple operations or callbacks.\n\n**Key Features:**\n\n- Arrow functions do not have their own `this`, `arguments`, `super`, or `new.target` bindings. They inherit these from their surrounding (lexical) context.\n- They are best suited for non-method functions, such as callbacks or simple computations.\n- Arrow functions cannot be used as constructors and do not have a `prototype` property.\n- They also cannot be used with `new`, `yield`, or as generator functions.\n\n**Syntax Examples:**\n```javascript\nconst arrowFunc1 = (a, b) => a + b;    // Multiple parameters, returns a + b\nconst arrowFunc2 = a => a * 10;        // Single parameter (parentheses optional), returns a * 10\nconst arrowFunc3 = () => {};           // No parameters, returns undefined\nconst arrowFunc4 = (a, b) => {\n  // Multiple statements require curly braces and explicit return\n  const sum = a + b;\n  return sum * 2;\n};\n```"
    },
    {
      "id": 11,
      "question": "What is a first class function",
      "answer": "In JavaScript, first-class functions (first-class citizens) mean that functions are treated like any other variable. That means:\n\n- You can assign a function to a variable.\n- You can pass a function as an argument to another function.\n- You can return a function from another function.\n\nThis capability enables powerful patterns like callbacks, higher-order functions, event handling, and functional programming in JavaScript.\n\nFor example, the handler function below is assigned to a variable and then passed as an argument to the addEventListener method.\n\n```javascript\nconst handler = () => console.log(\"This is a click handler function\");\ndocument.addEventListener(\"click\", handler);\n```"
    },
    {
      "id": 12,
      "question": "What is a first order function",
      "answer": "A first-order function is a function that doesn't accept another function as an argument and doesn't return a function as its return value. i.e, It's a regular function that works with primitive or non-function values.\n\n```javascript\nconst firstOrder = () => console.log(\"I am a first order function!\");\n```"
    },
    {
      "id": 13,
      "question": "What is a higher order function",
      "answer": "A higher-order function is a function that either accepts another function as an argument, returns a function as its result, or both. This concept is a core part of JavaScript's functional programming capabilities and is widely used for creating modular, reusable, and expressive code.\n\nThe syntactic structure of higher order function will be explained with an example as follows:\n\n```javascript\n// First-order function (does not accept or return another function)\nconst firstOrderFunc = () => \n  console.log(\"Hello, I am a first-order function\");\n\n// Higher-order function (accepts a function as an argument)\nconst higherOrder = (callback) => callback();\n\n// Passing the first-order function to the higher-order function\nhigherOrder(firstOrderFunc);\n```\n\nIn this example:\n\n- `firstOrderFunc` is a regular (first-order) function.\n- `higherOrder` is a higher-order function because it takes another function as an argument.\n- `firstOrderFunc` is also called a callback function because it is passed to and executed by another function."
    },
    {
      "id": 14,
      "question": "What is a unary function",
      "answer": "A unary function (also known as a monadic function) is a function that accepts exactly one argument. The term \"unary\" simply refers to the function's arity‚Äîthe number of arguments it takes.\n\nLet us take an example of unary function:\n\n```javascript\nconst unaryFunction = (a) => console.log(a + 10); // This will add 10 to the input and log the result\nunaryFunction(5); // Output: 15\n```\n\nIn this example:\n\n- `unaryFunction` takes a single parameter `a`, making it a unary function.\n- It performs a simple operation: adding 10 to the input and printing the result."
    },
    {
      "id": 15,
      "question": "What is the currying function",
      "answer": "Currying is the process of transforming a function with multiple arguments into a sequence of nested functions, each accepting only one argument at a time.\n\nThis concept is named after mathematician Haskell Curry, and is commonly used in functional programming to enhance modularity and reuse.\n\n**Before Currying (Normal n-ary Function):**\n```javascript\nconst multiArgFunction = (a, b, c) => a + b + c;\n\nconsole.log(multiArgFunction(1, 2, 3)); // Output: 6\n```\nThis is a standard function that takes three arguments at once.\n\n**After Currying (Unary Function Chain):**\n```javascript\nconst curryUnaryFunction = (a) => (b) => (c) => a + b + c;\n\nconsole.log(curryUnaryFunction(1));       // Returns: function (b) => ...\nconsole.log(curryUnaryFunction(1)(2));    // Returns: function (c) => ...\nconsole.log(curryUnaryFunction(1)(2)(3)); // Output: 6\n```\nEach function in the chain accepts one argument and returns the next function, until all arguments are provided and the final result is computed.\n\n**Benefits of Currying:**\n\n- **Improves code reusability** ‚Üí You can partially apply functions with known arguments.\n- **Enhances functional composition** ‚Üí Easier to compose small, pure functions.\n- **Encourages clean, modular code** ‚Üí You can split logic into smaller single-responsibility functions."
    },
    {
      "id": 16,
      "question": "What is a pure function",
      "answer": "A pure function is a function whose output depends only on its input arguments and produces no side effects. This means that given the same inputs, a pure function will always return the same output, and it does not modify any external state or data.\n\nLet's take an example to see the difference between pure and impure functions:\n\n**Example: Pure vs. Impure Functions**\n```javascript\n// Impure Function\nlet numberArray = [];\nconst impureAddNumber = (number) => numberArray.push(number);\n\n// Pure Function\nconst pureAddNumber = (number) => (inputArray) =>\n  inputArray.concat([number]);\n\n// Usage\nconsole.log(impureAddNumber(6)); // returns 1\nconsole.log(numberArray);        // returns [6]\n\nconsole.log(pureAddNumber(7)(numberArray)); // returns [6, 7]\nconsole.log(numberArray);                   // remains [6]\n```\n\n- `impureAddNumber` changes the external variable `numberArray` and returns the new length of the array, making it impure.\n- `pureAddNumber` creates a new array with the added number and does not modify the original array, making it pure.\n\n**Benefits of Pure Functions:**\n\n- **Easier testing:** Since output depends only on input, pure functions are simple to test.\n- **Predictability:** No hidden side effects make behavior easier to reason about.\n- **Immutability:** Pure functions align with ES6 best practices, such as preferring const over let, supporting safer and more maintainable code.\n- **No side effects:** Reduces bugs related to shared state or mutation."
    },
    {
      "id": 17,
      "question": "What is the purpose of the let keyword",
      "answer": "The let keyword in JavaScript is used to declare a block-scoped local variable. This means that variables declared with let are only accessible within the block, statement, or expression where they are defined. This is a significant improvement over the older var keyword, which is function-scoped (or globally-scoped if declared outside a function), and does not respect block-level scoping.\n\n**Key Features of let:**\n\n- **Block Scope:** The variable exists only within the nearest enclosing block (e.g., inside an {} pair).\n- **No Hoisting Issues:** While let declarations are hoisted, they are not initialized until the code defining them is executed. Accessing them before declaration results in a ReferenceError (temporal dead zone).\n- **No Redeclaration:** The same variable cannot be declared twice in the same scope with let.\n\n**Example:**\n```javascript\nlet counter = 30;\nif (counter === 30) {\n  let counter = 31;\n  console.log(counter); // Output: 31 (block-scoped variable inside if-block)\n}\nconsole.log(counter); // Output: 30 (outer variable, unaffected by inner block)\n```\n\nIn this example, the counter inside the if block is a separate variable from the one outside. The let keyword ensures that both have their own distinct scope.\n\nIn summary, you need to use let when you want variables to be limited to the block in which they are defined, preventing accidental overwrites and bugs related to variable scope."
    },
    {
      "id": 18,
      "question": "What is the difference between let and var",
      "answer": "You can list out the differences in a tabular format:\n\n| Feature | var | let |\n|---------|-----|-----|\n| **Availability** | Available from the beginning of JavaScript | Introduced as part of ES6 |\n| **Scope** | Function scope | Block scope |\n| **Hoisting** | Variable declaration will be hoisted, initialized as undefined | Hoisted but not initialized |\n| **Redeclaration** | Possible to re-declare the variable in the same scope | Not possible to re-declare the variable |\n\nLet's take an example to see the difference:\n\n```javascript\nfunction userDetails(username) {\n  if (username) {\n    console.log(salary); // undefined due to hoisting\n    console.log(age); // ReferenceError: Cannot access 'age' before initialization\n    let age = 30;\n    var salary = 10000;\n  }\n  console.log(salary); //10000 (accessible due to function scope)\n  console.log(age); //error: age is not defined(due to block scope)\n}\nuserDetails(\"John\");\n```"
    },
    {
      "id": 19,
      "question": "What is the reason to choose the name let as a keyword",
      "answer": "The keyword let was chosen because it originates from mathematical notation, where \"let\" is used to introduce new variables (for example, \"let x = 5\"). This term was adopted by several early programming languages such as Scheme and BASIC, establishing a tradition in computer science. JavaScript follows this convention by using let to declare variables with block scope, providing a modern alternative to var. The choice helps make the language more familiar to programmers coming from other languages and aligns with the mathematical practice of variable assignment."
    },
    {
      "id": 20,
      "question": "How do you redeclare variables in a switch block without an error",
      "answer": "When you try to redeclare variables using let or const in multiple case clauses of a switch statement, you will get a SyntaxError. This happens because, in JavaScript, all case clauses within a switch statement share the same block scope. For example:\n\n```javascript\nlet counter = 1;\nswitch (x) {\n  case 0:\n    let name;\n    break;\n  case 1:\n    let name; // SyntaxError: Identifier 'name' has already been declared\n    break;\n}\n```\n\nTo avoid this error, you can create a new block scope within each case clause by wrapping the code in curly braces {}. This way, each let or const declaration is scoped only to that block, and redeclaration errors are avoided:\n\n```javascript\nlet counter = 1;\nswitch (x) {\n  case 0: {\n    let name;\n    // code for case 0\n    break;\n  }\n  case 1: {\n    let name; // No SyntaxError\n    // code for case 1\n    break;\n  }\n}\n```\n\nThat means, to safely redeclare variables in different cases of a switch statement, wrap each case's code in its own block using curly braces. This ensures each variable declaration is scoped to its specific case block."
    },
    {
      "id": 21,
      "question": "What is the Temporal Dead Zone",
      "answer": "The Temporal Dead Zone (TDZ) refers to the period between the start of a block and the point where a variable declared with let or const is initialized. During this time, the variable exists in scope but cannot be accessed, and attempting to do so results in a ReferenceError.\n\nThis behavior is part of JavaScript's ES6 (ECMAScript 2015) specification and applies only to variables declared with let and const, not var. Variables declared with var are hoisted and initialized with undefined, so accessing them before the declaration does not throw an error, though it can lead to unexpected results.\n\n**Example:**\n```javascript\nfunction someMethod() {\n    console.log(counter1); // Output: undefined (due to var hoisting)\n    console.log(counter2); // Throws ReferenceError (TDZ for let)\n\n    var counter1 = 1;\n    let counter2 = 2;\n}\n```"
    },
    {
      "id": 22,
      "question": "What is an IIFE (Immediately Invoked Function Expression)",
      "answer": "IIFE (Immediately Invoked Function Expression) is a JavaScript function that runs as soon as it is defined. The signature of it would be as below:\n\n```javascript\n(function () {\n  // logic here\n})();\n```\n\nThe primary reason to use an IIFE is to obtain data privacy because any variables declared within the IIFE cannot be accessed by the outside world. i.e, If you try to access variables from the IIFE then it throws an error as below:\n\n```javascript\n(function () {\n  var message = \"IIFE\";\n  console.log(message);\n})();\nconsole.log(message); //Error: message is not defined\n```"
    },
    {
      "id": 23,
      "question": "How do you decode or encode a URL in JavaScript?",
      "answer": "encodeURI() function is used to encode an URL. This function requires a URL string as a parameter and return that encoded string. decodeURI() function is used to decode an URL. This function requires an encoded URL string as parameter and return that decoded string.\n\nNote: If you want to encode characters such as / ? : @ & = + $ # then you need to use encodeURIComponent().\n\n```javascript\nlet uri = \"employeeDetails?name=john&occupation=manager\";\nlet encoded_uri = encodeURI(uri);\nlet decoded_uri = decodeURI(encoded_uri);\n```"
    },
    {
      "id": 24,
      "question": "What is memoization",
      "answer": "Memoization is a functional programming technique which attempts to increase a function's performance by caching its previously computed results. Each time a memoized function is called, its parameters are used to index the cache. If the data is present, then it can be returned, without executing the entire function. Otherwise the function is executed and then the result is added to the cache. Let's take an example of adding function with memoization:\n\n```javascript\nconst memoizeAddition = () => {\n  let cache = {};\n  return (value) => {\n    if (value in cache) {\n      console.log(\"Fetching from cache\");\n      return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier. Hence, can only be accessed using the square bracket notation.\n    } else {\n      console.log(\"Calculating result\");\n      let result = value + 20;\n      cache[value] = result;\n      return result;\n    }\n  };\n};\n// returned function from memoizeAddition\nconst addition = memoizeAddition();\nconsole.log(addition(20)); //output: 40 calculated\nconsole.log(addition(20)); //output: 40 cached\n```"
    },
    {
      "id": 25,
      "question": "What is Hoisting",
      "answer": "Hoisting is a JavaScript mechanism where variables, function declarations and classes are moved to the top of their scope before code execution. Remember that JavaScript only hoists declarations, not initialisation. Let's take a simple example of variable hoisting:\n\n```javascript\nconsole.log(message); //output : undefined\nvar message = \"The variable Has been hoisted\";\n```\n\nThe above code looks like as below to the interpreter:\n\n```javascript\nvar message;\nconsole.log(message);\nmessage = \"The variable Has been hoisted\";\n```\n\nIn the same fashion, function declarations are hoisted too:\n\n```javascript\nmessage(\"Good morning\"); //Good morning\n\nfunction message(name) {\n  console.log(name);\n}\n```\n\nThis hoisting makes functions to be safely used in code before they are declared."
    },
    {
      "id": 26,
      "question": "What are classes in ES6",
      "answer": "In ES6, Javascript classes are primarily syntactic sugar over JavaScript's existing prototype-based inheritance. For example, the prototype based inheritance written in function expression as below:\n\n```javascript\nfunction Bike(model, color) {\n  this.model = model;\n  this.color = color;\n}\n\nBike.prototype.getDetails = function () {\n  return this.model + \" bike has\" + this.color + \" color\";\n};\n```\n\nWhereas ES6 classes can be defined as an alternative:\n\n```javascript\nclass Bike {\n  constructor(color, model) {\n    this.color = color;\n    this.model = model;\n  }\n\n  getDetails() {\n    return this.model + \" bike has\" + this.color + \" color\";\n  }\n}\n```"
    },
    {
      "id": 27,
      "question": "What are closures",
      "answer": "A closure is the combination of a function bundled (enclosed) together with its lexical environment within which that function was declared. In other words, it is an inner function that has access to the outer or enclosing function's variables, functions, and other data even after the outer function has finished its execution.\\n\\n**The closure has three scope chains:**\\n\\n1. **Own scope** - variables defined between its curly brackets\\n2. **Outer function's variables** - variables from the enclosing function\\n3. **Global variables** - variables in the global scope\\n\\n**Example:**\\n```javascript\\nfunction Welcome(name) {\\n  var greetingInfo = function (message) {\\n    console.log(message + \\\" \\\" + name);\\n  };\\n  return greetingInfo;\\n}\\n\\nvar myFunction = Welcome(\\\"John\\\");\\nmyFunction(\\\"Welcome \\\"); // Output: Welcome John\\nmyFunction(\\\"Hello Mr.\\\"); // Output: Hello Mr. John\\n```\\n\\nAs per the above code, the inner function (`greetingInfo`) has access to the variables in the outer function scope (`Welcome`) even after the outer function has returned.\\n\\n**Key Points:**\\n- Closures \\\"remember\\\" the environment in which they were created\\n- They provide data privacy and encapsulation\\n- Commonly used in module patterns, callbacks, and event handlers\\n- Essential for understanding JavaScript's functional programming capabilities"
    },
    {
      "id": 28,
      "question": "What are modules",
      "answer": "Modules refer to small units of independent, reusable code and also act as the foundation of many JavaScript design patterns. Most JavaScript modules export an object literal, a function, or a constructor.\n\n**Types of Modules:**\n\n**1. CommonJS (Node.js):**\n```javascript\n// math.js\nconst add = (a, b) => a + b;\nconst subtract = (a, b) => a - b;\n\nmodule.exports = { add, subtract };\n\n// main.js\nconst { add, subtract } = require('./math');\nconsole.log(add(5, 3)); // 8\n```\n\n**2. ES6 Modules (ESM):**\n```javascript\n// math.js\nexport const add = (a, b) => a + b;\nexport const subtract = (a, b) => a - b;\n\n// main.js\nimport { add, subtract } from './math.js';\nconsole.log(add(5, 3)); // 8\n```\n\n**3. AMD (Asynchronous Module Definition):**\n```javascript\n// Using RequireJS\ndefine(['dependency'], function(dependency) {\n  return {\n    doSomething: function() {\n      return dependency.helper();\n    }\n  };\n});\n```\n\n**Benefits:**\n- **Maintainability** - easier to maintain and update code\n- **Reusability** - code can be reused across different parts of an application\n- **Namespacing** - prevents global namespace pollution"
    },
    {
      "id": 29,
      "question": "Why do you need modules",
      "answer": "Below are the list of benefits of using modules in the JavaScript ecosystem:\n\n**1. Maintainability**\n- Code is organized into logical, self-contained units\n- Easier to debug, test, and update specific functionality\n- Changes to one module don't affect others if interfaces remain consistent\n- Smaller, focused files are easier to understand and work with\n\n**2. Reusability**\n- Write once, use many times across different parts of an application\n- Modules can be shared between different projects\n- Reduces code duplication and development time\n- Promotes DRY (Don't Repeat Yourself) principle\n\n**3. Namespacing**\n- Prevents global namespace pollution\n- Avoids naming conflicts between different parts of an application\n- Encapsulates functionality within module scope\n- Makes dependencies explicit and manageable\n\n**Additional Benefits:**\n- **Dependency Management** - Clear declaration of what each module needs\n- **Testing** - Individual modules can be unit tested in isolation\n- **Lazy Loading** - Modules can be loaded on-demand for better performance\n- **Team Collaboration** - Different developers can work on separate modules simultaneously"
    },
    {
      "id": 30,
      "question": "What is scope in JavaScript",
      "answer": "Scope is the accessibility of variables, functions, and objects in some particular part of your code during runtime. In other words, scope determines the visibility of variables and other resources in areas of your code.\n\n**Types of Scope:**\n\n**1. Global Scope**\n```javascript\nvar globalVar = \"I'm global\";\n\nfunction test() {\n  console.log(globalVar); // Accessible\n}\n```\n\n**2. Function Scope**\n```javascript\nfunction myFunction() {\n  var functionScoped = \"I'm function scoped\";\n  console.log(functionScoped); // Accessible\n}\n// console.log(functionScoped); // ReferenceError\n```\n\n**3. Block Scope (ES6+)**\n```javascript\nif (true) {\n  let blockScoped = \"I'm block scoped\";\n  const alsoBlockScoped = \"Me too\";\n  console.log(blockScoped); // Accessible\n}\n// console.log(blockScoped); // ReferenceError\n```\n\n**4. Module Scope**\n```javascript\n// Variables declared at the top level of a module\n// are scoped to that module\nlet moduleScoped = \"I'm module scoped\";\n```\n\n**Scope Chain:**\nJavaScript uses lexical scoping, meaning inner functions have access to variables in their outer scope:\n\n```javascript\nfunction outer() {\n  let outerVar = \"outer\";\n  \n  function inner() {\n    let innerVar = \"inner\";\n    console.log(outerVar); // Accessible via scope chain\n    console.log(innerVar); // Accessible in current scope\n  }\n  \n  inner();\n}\n```"
    },
    {
      "id": 31,
      "question": "What is a service worker",
      "answer": "A Service Worker is a script that runs in the background, separate from a web page, opening the door to features that don't need a web page or user interaction. Service workers essentially act as proxy servers that sit between web applications, the browser, and the network (when available).\n\n**Key Features:**\n- **Network Proxy** - Intercept and handle network requests\n- **Background Processing** - Run even when the web page is closed\n- **Push Notifications** - Receive and display notifications\n- **Background Sync** - Sync data when connectivity is restored\n- **Caching** - Cache resources for offline functionality\n\n**Lifecycle:**\n```javascript\n// Registration\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker.register('/sw.js')\n    .then(registration => {\n      console.log('SW registered:', registration);\n    })\n    .catch(error => {\n      console.log('SW registration failed:', error);\n    });\n}\n\n// Service Worker Script (sw.js)\nself.addEventListener('install', event => {\n  console.log('Service worker installing...');\n  // Cache resources\n  event.waitUntil(\n    caches.open('v1').then(cache => {\n      return cache.addAll([\n        '/',\n        '/styles.css',\n        '/script.js'\n      ]);\n    })\n  );\n});\n\nself.addEventListener('fetch', event => {\n  event.respondWith(\n    caches.match(event.request).then(response => {\n      return response || fetch(event.request);\n    })\n  );\n});\n```\n\n**Use Cases:**\n- Progressive Web Apps (PWAs)\n- Offline functionality\n- Background data synchronization\n- Push notifications\n- Performance optimization through caching"
    },
    {
      "id": 32,
      "question": "How do you manipulate DOM using a service worker",
      "answer": "Service workers **cannot directly manipulate the DOM** because they run in a separate thread from the main JavaScript thread. However, they can communicate with the main thread (which has DOM access) using the `postMessage` API.\n\n**Communication Pattern:**\n\n**1. Service Worker to Main Thread:**\n```javascript\n// In service worker (sw.js)\nself.addEventListener('fetch', event => {\n  if (event.request.url.includes('/api/data')) {\n    // Send message to main thread\n    self.clients.matchAll().then(clients => {\n      clients.forEach(client => {\n        client.postMessage({\n          type: 'DATA_UPDATED',\n          data: 'New data available'\n        });\n      });\n    });\n  }\n});\n\n// In main thread\nnavigator.serviceWorker.addEventListener('message', event => {\n  if (event.data.type === 'DATA_UPDATED') {\n    // Now we can manipulate DOM\n    document.getElementById('status').textContent = event.data.data;\n  }\n});\n```\n\n**2. Main Thread to Service Worker:**\n```javascript\n// In main thread\nfunction updateServiceWorker(data) {\n  navigator.serviceWorker.controller.postMessage({\n    type: 'UPDATE_CACHE',\n    data: data\n  });\n}\n\n// In service worker\nself.addEventListener('message', event => {\n  if (event.data.type === 'UPDATE_CACHE') {\n    // Handle cache update\n    caches.open('dynamic-cache').then(cache => {\n      cache.put('/api/data', new Response(JSON.stringify(event.data.data)));\n    });\n  }\n});\n```\n\n**Alternative Approaches:**\n- Use **BroadcastChannel API** for cross-tab communication\n- Store data in **IndexedDB** and have main thread poll for changes\n- Use **Push API** to trigger events that main thread can handle"
    },
    {
      "id": 33,
      "question": "How do you reuse information across service worker restarts",
      "answer": "Service workers can be terminated by the browser at any time and restarted when needed. To persist information across restarts, you need to use persistent storage mechanisms.\n\n**Storage Options:**\n\n**1. IndexedDB (Recommended):**\n```javascript\n// Store data\nself.addEventListener('message', event => {\n  if (event.data.type === 'STORE_DATA') {\n    const request = indexedDB.open('ServiceWorkerDB', 1);\n    \n    request.onsuccess = event => {\n      const db = event.target.result;\n      const transaction = db.transaction(['data'], 'readwrite');\n      const store = transaction.objectStore('data');\n      store.put(event.data.payload, 'userPreferences');\n    };\n  }\n});\n\n// Retrieve data on restart\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    new Promise((resolve) => {\n      const request = indexedDB.open('ServiceWorkerDB', 1);\n      \n      request.onsuccess = event => {\n        const db = event.target.result;\n        const transaction = db.transaction(['data'], 'readonly');\n        const store = transaction.objectStore('data');\n        const getRequest = store.get('userPreferences');\n        \n        getRequest.onsuccess = () => {\n          self.userData = getRequest.result;\n          resolve();\n        };\n      };\n    })\n  );\n});\n```\n\n**2. Cache API:**\n```javascript\n// Store configuration in cache\nself.addEventListener('install', event => {\n  event.waitUntil(\n    caches.open('config-cache').then(cache => {\n      return cache.put('/config', new Response(JSON.stringify({\n        version: '1.0',\n        settings: {...}\n      })));\n    })\n  );\n});\n\n// Retrieve on restart\nself.addEventListener('activate', event => {\n  event.waitUntil(\n    caches.match('/config').then(response => {\n      if (response) {\n        return response.json().then(config => {\n          self.appConfig = config;\n        });\n      }\n    })\n  );\n});\n```\n\n**3. postMessage to retrieve from main thread:**\n```javascript\nself.addEventListener('activate', event => {\n  // Request data from main thread\n  self.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n      client.postMessage({ type: 'REQUEST_APP_STATE' });\n    });\n  });\n});\n```"
    },
    {
      "id": 34,
      "question": "What is IndexedDB",
      "answer": "IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. This API uses indexes to enable high-performance searches of this data. It's a NoSQL database built into the browser.\\n\\n**Key Features:**\\n- **Transactional** - All operations happen within transactions\\n- **Asynchronous** - Non-blocking operations using callbacks/promises\\n- **Large Storage** - Can store much more data than localStorage\\n- **Structured Data** - Can store JavaScript objects, arrays, etc.\\n- **Indexed** - Fast searches using indexes\\n\\n**Basic Usage:**\\n```javascript\\n// Open database\\nconst request = indexedDB.open('MyDatabase', 1);\\n\\nrequest.onerror = event => {\\n  console.error('Database error:', event.target.error);\\n};\\n\\nrequest.onsuccess = event => {\\n  const db = event.target.result;\\n  console.log('Database opened successfully');\\n};\\n\\nrequest.onupgradeneeded = event => {\\n  const db = event.target.result;\\n  \\n  // Create object store\\n  const objectStore = db.createObjectStore('users', { keyPath: 'id' });\\n  \\n  // Create indexes\\n  objectStore.createIndex('name', 'name', { unique: false });\\n  objectStore.createIndex('email', 'email', { unique: true });\\n};\\n\\n// Add data\\nfunction addUser(user) {\\n  const transaction = db.transaction(['users'], 'readwrite');\\n  const objectStore = transaction.objectStore('users');\\n  const request = objectStore.add(user);\\n  \\n  request.onsuccess = () => {\\n    console.log('User added successfully');\\n  };\\n}\\n\\n// Get data\\nfunction getUser(id) {\\n  const transaction = db.transaction(['users'], 'readonly');\\n  const objectStore = transaction.objectStore('users');\\n  const request = objectStore.get(id);\\n  \\n  request.onsuccess = event => {\\n    const user = event.target.result;\\n    console.log('User found:', user);\\n  };\\n}\\n```"
    },
    {
      "id": 35,
      "question": "What is web storage",
      "answer": "Web storage provides mechanisms by which browsers can store key/value pairs locally within a user's browser, much more intuitively than using cookies. It consists of two main types: localStorage and sessionStorage.\\n\\n**Types of Web Storage:**\\n\\n**1. localStorage:**\\n- **Persistent** - Data survives browser restart\\n- **Domain-specific** - Data is only available to the domain that created it\\n- **Size limit** - Typically 5-10MB per domain\\n- **Synchronous API** - Blocking operations\\n\\n```javascript\\n// Store data\\nlocalStorage.setItem('username', 'john_doe');\\nlocalStorage.setItem('preferences', JSON.stringify({theme: 'dark'}));\\n\\n// Retrieve data\\nconst username = localStorage.getItem('username');\\nconst preferences = JSON.parse(localStorage.getItem('preferences'));\\n\\n// Remove data\\nlocalStorage.removeItem('username');\\n\\n// Clear all data\\nlocalStorage.clear();\\n\\n// Get number of items\\nconsole.log(localStorage.length);\\n\\n// Get key by index\\nfor (let i = 0; i < localStorage.length; i++) {\\n  const key = localStorage.key(i);\\n  const value = localStorage.getItem(key);\\n  console.log(key, value);\\n}\\n```\\n\\n**2. sessionStorage:**\\n- **Temporary** - Data is cleared when tab is closed\\n- **Tab-specific** - Each tab has its own sessionStorage\\n- **Same API as localStorage**\\n\\n```javascript\\n// Same API as localStorage\\nsessionStorage.setItem('tempData', 'value');\\nconst tempData = sessionStorage.getItem('tempData');\\nsessionStorage.removeItem('tempData');\\n```\\n\\n**Storage Events:**\\n```javascript\\n// Listen for storage changes (only fires on other tabs/windows)\\nwindow.addEventListener('storage', event => {\\n  console.log('Storage changed:', {\\n    key: event.key,\\n    oldValue: event.oldValue,\\n    newValue: event.newValue,\\n    url: event.url\\n  });\\n});\\n```"
    },
    {
      "id": 36,
      "question": "How do you store the data in web storage",
      "answer": "Data in web storage is stored as key-value pairs where both keys and values must be strings. For complex data types, you need to serialize them to strings using JSON.stringify().\\n\\n**Basic Storage Operations:**\\n\\n**1. Storing Simple Data:**\\n```javascript\\n// Store strings\\nlocalStorage.setItem('name', 'John Doe');\\nlocalStorage.setItem('age', '25'); // Numbers must be strings\\nlocalStorage.setItem('isActive', 'true'); // Booleans must be strings\\n\\n// Alternative syntax\\nlocalStorage.name = 'John Doe';\\nlocalStorage['age'] = '25';\\n```\\n\\n**2. Storing Objects and Arrays:**\\n```javascript\\n// Store objects\\nconst user = {\\n  id: 1,\\n  name: 'John Doe',\\n  email: 'john@example.com',\\n  preferences: {\\n    theme: 'dark',\\n    language: 'en'\\n  }\\n};\\n\\nlocalStorage.setItem('user', JSON.stringify(user));\\n\\n// Store arrays\\nconst items = ['apple', 'banana', 'orange'];\\nlocalStorage.setItem('fruits', JSON.stringify(items));\\n\\n// Store complex nested data\\nconst appState = {\\n  currentUser: user,\\n  settings: {\\n    notifications: true,\\n    autoSave: false\\n  },\\n  recentItems: items\\n};\\n\\nlocalStorage.setItem('appState', JSON.stringify(appState));\\n```\\n\\n**3. Retrieving and Parsing Data:**\\n```javascript\\n// Retrieve and parse objects\\nconst storedUser = JSON.parse(localStorage.getItem('user'));\\nconst storedFruits = JSON.parse(localStorage.getItem('fruits'));\\n\\n// Handle null values\\nconst data = localStorage.getItem('nonexistent'); // returns null\\n```\\n\\n**4. Helper Functions:**\\n```javascript\\n// Storage utility class\\nclass StorageManager {\\n  static set(key, value) {\\n    try {\\n      localStorage.setItem(key, JSON.stringify(value));\\n      return true;\\n    } catch (error) {\\n      console.error('Storage error:', error);\\n      return false;\\n    }\\n  }\\n  \\n  static get(key, defaultValue = null) {\\n    try {\\n      const item = localStorage.getItem(key);\\n      return item ? JSON.parse(item) : defaultValue;\\n    } catch (error) {\\n      console.error('Parse error:', error);\\n      return defaultValue;\\n    }\\n  }\\n  \\n  static remove(key) {\\n    localStorage.removeItem(key);\\n  }\\n  \\n  static clear() {\\n    localStorage.clear();\\n  }\\n}\\n```"
    },
    {
      "id": 37,
      "question": "How do you access web storage",
      "answer": "Web storage can be accessed through the global `localStorage` and `sessionStorage` objects available in the browser's window object. Both provide the same API methods for storing and retrieving data.\\n\\n**Access Methods:**\\n\\n**1. Direct Property Access:**\\n```javascript\\n// Set values\\nlocalStorage.username = 'john_doe';\\nsessionStorage.tempData = 'temporary';\\n\\n// Get values\\nconst username = localStorage.username;\\nconst tempData = sessionStorage.tempData;\\n\\n// Delete values\\ndelete localStorage.username;\\ndelete sessionStorage.tempData;\\n```\\n\\n**2. Bracket Notation:**\\n```javascript\\n// Set values\\nlocalStorage['user-id'] = '12345';\\nsessionStorage['session-token'] = 'abc123';\\n\\n// Get values\\nconst userId = localStorage['user-id'];\\nconst sessionToken = sessionStorage['session-token'];\\n\\n// Delete values\\ndelete localStorage['user-id'];\\n```\\n\\n**3. Storage API Methods (Recommended):**\\n```javascript\\n// setItem(key, value)\\nlocalStorage.setItem('theme', 'dark');\\nsessionStorage.setItem('currentPage', 'dashboard');\\n\\n// getItem(key) - returns null if key doesn't exist\\nconst theme = localStorage.getItem('theme');\\nconst currentPage = sessionStorage.getItem('currentPage');\\n\\n// removeItem(key)\\nlocalStorage.removeItem('theme');\\nsessionStorage.removeItem('currentPage');\\n\\n// clear() - removes all items\\nlocalStorage.clear();\\nsessionStorage.clear();\\n\\n// key(index) - get key name by index\\nfor (let i = 0; i < localStorage.length; i++) {\\n  const key = localStorage.key(i);\\n  const value = localStorage.getItem(key);\\n  console.log(key, value);\\n}\\n\\n// length property\\nconsole.log('localStorage has', localStorage.length, 'items');\\n```\\n\\n**4. Feature Detection:**\\n```javascript\\n// Check if web storage is supported\\nfunction isStorageSupported(type) {\\n  try {\\n    const storage = window[type];\\n    const test = '__storage_test__';\\n    storage.setItem(test, test);\\n    storage.removeItem(test);\\n    return true;\\n  } catch (error) {\\n    return false;\\n  }\\n}\\n\\nif (isStorageSupported('localStorage')) {\\n  // Use localStorage\\n  localStorage.setItem('data', 'value');\\n} else {\\n  // Fallback to cookies or other storage method\\n  console.log('localStorage not supported');\\n}\\n```\\n\\n**5. Cross-Browser Compatibility:**\\n```javascript\\n// Storage wrapper for older browsers\\nconst Storage = {\\n  set: function(key, value) {\\n    if (typeof(Storage) !== 'undefined') {\\n      localStorage.setItem(key, value);\\n    } else {\\n      // Fallback for older browsers\\n      document.cookie = key + '=' + value;\\n    }\\n  },\\n  \\n  get: function(key) {\\n    if (typeof(Storage) !== 'undefined') {\\n      return localStorage.getItem(key);\\n    } else {\\n      // Parse from cookies\\n      const cookies = document.cookie.split(';');\\n      for (let cookie of cookies) {\\n        const [name, value] = cookie.trim().split('=');\\n        if (name === key) return value;\\n      }\\n      return null;\\n    }\\n  }\\n};\\n```"
    },
    {
      "id": 38,
      "question": "What are the methods available on session storage",
      "answer": "SessionStorage provides the same methods as localStorage, following the Web Storage API specification. Here are all the available methods and properties:\\n\\n**Core Methods:**\\n\\n**1. setItem(key, value)**\\n```javascript\\n// Store data (both key and value must be strings)\\nsessionStorage.setItem('username', 'john_doe');\\nsessionStorage.setItem('userPrefs', JSON.stringify({theme: 'dark'}));\\n```\\n\\n**2. getItem(key)**\\n```javascript\\n// Retrieve data (returns null if key doesn't exist)\\nconst username = sessionStorage.getItem('username');\\nconst userPrefs = JSON.parse(sessionStorage.getItem('userPrefs'));\\n\\n// Handle null values\\nconst data = sessionStorage.getItem('nonexistent'); // returns null\\n```\\n\\n**3. removeItem(key)**\\n```javascript\\n// Remove specific item\\nsessionStorage.removeItem('username');\\n\\n// Safe removal (won't throw error if key doesn't exist)\\nsessionStorage.removeItem('nonexistent'); // No error\\n```\\n\\n**4. clear()**\\n```javascript\\n// Remove all items from sessionStorage\\nsessionStorage.clear();\\n```\\n\\n**5. key(index)**\\n```javascript\\n// Get key name by index\\nfor (let i = 0; i < sessionStorage.length; i++) {\\n  const keyName = sessionStorage.key(i);\\n  const value = sessionStorage.getItem(keyName);\\n  console.log(`${keyName}: ${value}`);\\n}\\n\\n// Get specific key by index\\nconst firstKey = sessionStorage.key(0);\\nconst lastKey = sessionStorage.key(sessionStorage.length - 1);\\n```\\n\\n**Properties:**\\n\\n**1. length**\\n```javascript\\n// Get number of items stored\\nconsole.log(sessionStorage.length); // e.g., 5\\n\\n// Check if storage is empty\\nif (sessionStorage.length === 0) {\\n  console.log('Session storage is empty');\\n}\\n```\\n\\n**Utility Examples:**\\n```javascript\\n// Get all keys\\nfunction getAllKeys() {\\n  const keys = [];\\n  for (let i = 0; i < sessionStorage.length; i++) {\\n    keys.push(sessionStorage.key(i));\\n  }\\n  return keys;\\n}\\n\\n// Get all items\\nfunction getAllItems() {\\n  const items = {};\\n  for (let i = 0; i < sessionStorage.length; i++) {\\n    const key = sessionStorage.key(i);\\n    items[key] = sessionStorage.getItem(key);\\n  }\\n  return items;\\n}\\n\\n// Check if key exists\\nfunction hasKey(key) {\\n  return sessionStorage.getItem(key) !== null;\\n}\\n\\n// Safe JSON operations\\nfunction setJSON(key, object) {\\n  try {\\n    sessionStorage.setItem(key, JSON.stringify(object));\\n    return true;\\n  } catch (error) {\\n    console.error('Error storing JSON:', error);\\n    return false;\\n  }\\n}\\n\\nfunction getJSON(key, defaultValue = null) {\\n  try {\\n    const item = sessionStorage.getItem(key);\\n    return item ? JSON.parse(item) : defaultValue;\\n  } catch (error) {\\n    console.error('Error parsing JSON:', error);\\n    return defaultValue;\\n  }\\n}\\n```"
    },
    {
      "id": 39,
      "question": "What is a Cookie",
      "answer": "A cookie is a small piece of data that a server sends to a user's web browser. The browser stores it and sends it back with later requests to the same server. Cookies are mainly used for session management, personalization, and tracking.\\n\\n**Cookie Characteristics:**\\n- **Size Limit**: Maximum 4KB per cookie\\n- **Domain Specific**: Only sent to the domain that created them\\n- **Automatic**: Sent with every HTTP request to the domain\\n- **Expirable**: Can have expiration dates\\n- **Secure**: Can be restricted to HTTPS only\\n\\n**Cookie Attributes:**\\n\\n| Attribute | Description | Example |\\n|-----------|-------------|---------|\\n| **Name=Value** | The cookie data | `username=john_doe` |\\n| **Expires** | Expiration date | `expires=Wed, 21 Oct 2025 07:28:00 GMT` |\\n| **Max-Age** | Seconds until expiry | `max-age=3600` (1 hour) |\\n| **Domain** | Which domains can access | `domain=.example.com` |\\n| **Path** | Which paths can access | `path=/admin` |\\n| **Secure** | HTTPS only | `secure` |\\n| **HttpOnly** | No JavaScript access | `httponly` |\\n| **SameSite** | Cross-site request policy | `samesite=strict` |\\n\\n**Creating Cookies with JavaScript:**\\n\\n```javascript\\n// Basic cookie\\ndocument.cookie = 'username=john_doe';\\n\\n// Cookie with expiration (1 day)\\nconst expires = new Date();\\nexpires.setTime(expires.getTime() + (24 * 60 * 60 * 1000));\\ndocument.cookie = `sessionId=abc123; expires=${expires.toUTCString()}`;\\n\\n// Cookie with multiple attributes\\ndocument.cookie = 'theme=dark; max-age=86400; path=/; secure; samesite=strict';\\n\\n// Cookie utility functions\\nfunction setCookie(name, value, days) {\\n  const expires = new Date();\\n  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));\\n  document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`;\\n}\\n\\nfunction getCookie(name) {\\n  const nameEQ = name + '=';\\n  const ca = document.cookie.split(';');\\n  for (let i = 0; i < ca.length; i++) {\\n    let c = ca[i];\\n    while (c.charAt(0) === ' ') c = c.substring(1, c.length);\\n    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\\n  }\\n  return null;\\n}\\n\\nfunction deleteCookie(name) {\\n  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;\\n}\\n```\\n\\n**Common Use Cases:**\\n- **Session Management**: Login status, shopping carts\\n- **Personalization**: User preferences, themes\\n- **Tracking**: Analytics, advertising\\n- **Security**: CSRF tokens, authentication"
    },
    {
      "id": 40,
      "question": "Why do you need a Cookie",
      "answer": "Cookies are essential for web applications because HTTP is a stateless protocol, meaning each request is independent and the server doesn't remember previous interactions. Cookies provide a way to maintain state and context across multiple requests.\\n\\n**Primary Reasons for Using Cookies:**\\n\\n**1. Session Management**\\n```javascript\\n// Login session tracking\\nfunction loginUser(username, sessionToken) {\\n  // Set session cookie that expires when browser closes\\n  document.cookie = `sessionToken=${sessionToken}; path=/; secure; httponly`;\\n  document.cookie = `username=${username}; path=/; max-age=86400`; // 24 hours\\n}\\n\\n// Shopping cart that survives browser restart\\nfunction addToCart(itemId) {\\n  const cart = getCookie('cart') ? JSON.parse(getCookie('cart')) : [];\\n  cart.push(itemId);\\n  localStorage.setItem('cart', JSON.stringify(cart));\\n}\\n```\\n\\n**2. Personalization and User Preferences**\\n```javascript\\n// Theme preference\\nfunction setTheme(theme) {\\n  document.cookie = `theme=${theme}; max-age=31536000; path=/`; // 1 year\\n  applyTheme(theme);\\n}\\n\\n// Language preference\\nfunction setLanguage(lang) {\\n  document.cookie = `lang=${lang}; max-age=31536000; path=/`;\\n  location.reload(); // Reload to apply language\\n}\\n\\n// User settings\\nfunction saveUserSettings(settings) {\\n  document.cookie = `settings=${JSON.stringify(settings)}; max-age=2592000; path=/`; // 30 days\\n}\\n```\\n\\n**3. Analytics and Tracking**\\n```javascript\\n// User tracking for analytics\\nfunction trackUser() {\\n  let userId = getCookie('userId');\\n  if (!userId) {\\n    userId = generateUniqueId();\\n    setCookie('userId', userId, 365); // 1 year\\n  }\\n  \\n  // Track page visit\\n  sendAnalytics('pageview', { userId, page: window.location.pathname });\\n}\\n\\n// A/B testing\\nfunction assignTestGroup() {\\n  let testGroup = getCookie('testGroup');\\n  if (!testGroup) {\\n    testGroup = Math.random() < 0.5 ? 'A' : 'B';\\n    setCookie('testGroup', testGroup, 30); // 30 days\\n  }\\n  return testGroup;\\n}\\n```\\n\\n**4. Security and Authentication**\\n```javascript\\n// CSRF protection\\nfunction setCSRFToken(token) {\\n  document.cookie = `csrfToken=${token}; path=/; secure; samesite=strict`;\\n}\\n\\n// Remember me functionality\\nfunction rememberUser(username, rememberToken) {\\n  if (rememberMe) {\\n    setCookie('rememberToken', rememberToken, 30); // 30 days\\n    setCookie('username', username, 30);\\n  }\\n}\\n```\\n\\n**5. Performance Optimization**\\n```javascript\\n// Cache user preferences to avoid server requests\\nfunction getCachedUserPreferences() {\\n  const cached = getCookie('userPrefs');\\n  if (cached) {\\n    return JSON.parse(cached);\\n  }\\n  \\n  // Fetch from server if not cached\\n  return fetchUserPreferencesFromServer().then(prefs => {\\n    setCookie('userPrefs', JSON.stringify(prefs), 1); // Cache for 1 day\\n    return prefs;\\n  });\\n}\\n```\\n\\n**Key Benefits:**\\n- **Stateful Experience**: Maintain user context across page reloads\\n- **Automatic Transmission**: Sent with every request automatically\\n- **Cross-Tab Sharing**: Available across all tabs of the same domain\\n- **Server-Side Access**: Can be read by server-side code\\n- **Persistent Storage**: Can survive browser restarts (unlike sessionStorage)\\n- **Security Features**: Support for secure, httpOnly, and sameSite attributes"
    },
    {
      "id": 41,
      "question": "How do you delete a cookie",
      "answer": "To delete a cookie in JavaScript, you need to set its expiration date to a past date. Since cookies cannot be directly deleted, this approach makes the browser automatically remove the expired cookie.\\n\\n**Basic Cookie Deletion:**\\n\\n```javascript\\n// Method 1: Set expiration to past date\\nfunction deleteCookie(name) {\\n  document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;\\n}\\n\\n// Method 2: Use max-age with negative value\\nfunction deleteCookieAlt(name) {\\n  document.cookie = `${name}=; max-age=-1; path=/;`;\\n}\\n\\n// Usage\\ndeleteCookie('username');\\ndeleteCookie('sessionToken');\\n```\\n\\n**Advanced Cookie Deletion (matching all attributes):**\\n\\n```javascript\\n// Delete cookie with specific path and domain\\nfunction deleteCookieAdvanced(name, path = '/', domain = '') {\\n  let cookieString = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`;\\n  \\n  if (domain) {\\n    cookieString += ` domain=${domain};`;\\n  }\\n  \\n  document.cookie = cookieString;\\n}\\n\\n// Examples\\ndeleteCookieAdvanced('sessionId', '/', '.example.com');\\ndeleteCookieAdvanced('adminToken', '/admin/', 'app.example.com');\\n```\\n\\n**Complete Cookie Management Utility:**\\n\\n```javascript\\nclass CookieManager {\\n  // Set cookie\\n  static set(name, value, options = {}) {\\n    const {\\n      expires = null,\\n      maxAge = null,\\n      path = '/',\\n      domain = '',\\n      secure = false,\\n      httpOnly = false,\\n      sameSite = 'lax'\\n    } = options;\\n    \\n    let cookieString = `${name}=${encodeURIComponent(value)}`;\\n    \\n    if (expires) {\\n      cookieString += `; expires=${expires}`;\\n    }\\n    \\n    if (maxAge) {\\n      cookieString += `; max-age=${maxAge}`;\\n    }\\n    \\n    cookieString += `; path=${path}`;\\n    \\n    if (domain) {\\n      cookieString += `; domain=${domain}`;\\n    }\\n    \\n    if (secure) {\\n      cookieString += '; secure';\\n    }\\n    \\n    if (httpOnly) {\\n      cookieString += '; httponly';\\n    }\\n    \\n    cookieString += `; samesite=${sameSite}`;\\n    \\n    document.cookie = cookieString;\\n  }\\n  \\n  // Get cookie\\n  static get(name) {\\n    const nameEQ = name + '=';\\n    const ca = document.cookie.split(';');\\n    \\n    for (let i = 0; i < ca.length; i++) {\\n      let c = ca[i];\\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\\n      if (c.indexOf(nameEQ) === 0) {\\n        return decodeURIComponent(c.substring(nameEQ.length, c.length));\\n      }\\n    }\\n    return null;\\n  }\\n  \\n  // Delete cookie\\n  static delete(name, path = '/', domain = '') {\\n    let cookieString = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`;\\n    \\n    if (domain) {\\n      cookieString += ` domain=${domain};`;\\n    }\\n    \\n    document.cookie = cookieString;\\n  }\\n  \\n  // Delete all cookies\\n  static deleteAll() {\\n    const cookies = document.cookie.split(';');\\n    \\n    for (let cookie of cookies) {\\n      const eqPos = cookie.indexOf('=');\\n      const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();\\n      this.delete(name);\\n    }\\n  }\\n  \\n  // Check if cookie exists\\n  static exists(name) {\\n    return this.get(name) !== null;\\n  }\\n  \\n  // Get all cookies\\n  static getAll() {\\n    const cookies = {};\\n    const ca = document.cookie.split(';');\\n    \\n    for (let cookie of ca) {\\n      const [name, value] = cookie.trim().split('=');\\n      if (name && value) {\\n        cookies[name] = decodeURIComponent(value);\\n      }\\n    }\\n    \\n    return cookies;\\n  }\\n}\\n\\n// Usage examples\\nCookieManager.set('username', 'john_doe', { maxAge: 86400 });\\nCookieManager.delete('username');\\nCookieManager.deleteAll();\\n```\\n\\n**Important Notes:**\\n- **Path and Domain Matching**: To delete a cookie, you must specify the same path and domain used when creating it\\n- **Secure Cookies**: Cannot be deleted from non-HTTPS pages if they were created as secure\\n- **HttpOnly Cookies**: Cannot be deleted via JavaScript (server-side only)"
    },
    {
      "id": 42,
      "question": "What are the differences between cookie, local storage and session storage",
      "answer": "Here's a comprehensive comparison of the three main client-side storage mechanisms:\\n\\n**Storage Comparison Table:**\\n\\n| Feature | **Cookies** | **localStorage** | **sessionStorage** |\\n|---------|-------------|------------------|-------------------|\\n| **Storage Limit** | 4KB per cookie | 5-10MB per domain | 5-10MB per domain |\\n| **Persistence** | Until expiration | Until manually cleared | Until tab closes |\\n| **Scope** | Domain + path | Domain + protocol | Domain + protocol + tab |\\n| **Server Access** | Sent with every HTTP request | Client-side only | Client-side only |\\n| **API** | document.cookie string | Storage API methods | Storage API methods |\\n| **Browser Support** | Universal | Modern browsers | Modern browsers |\\n| **Security** | secure, httpOnly, sameSite | None built-in | None built-in |\\n\\n**Detailed Differences:**\\n\\n**1. Data Persistence:**\\n```javascript\\n// Cookies - configurable expiration\\ndocument.cookie = 'data=value; max-age=3600'; // 1 hour\\ndocument.cookie = 'persistent=value; max-age=31536000'; // 1 year\\n\\n// localStorage - persists until manually cleared\\nlocalStorage.setItem('data', 'value'); // Survives browser restart\\n\\n// sessionStorage - cleared when tab closes\\nsessionStorage.setItem('data', 'value'); // Lost on tab close\\n```\\n\\n**2. Automatic Server Communication:**\\n```javascript\\n// Cookies - automatically sent with requests\\nfetch('/api/data'); // Cookies sent automatically\\n\\n// localStorage/sessionStorage - manual inclusion required\\nfetch('/api/data', {\\n  headers: {\\n    'Authorization': localStorage.getItem('token')\\n  }\\n});\\n```\\n\\n**3. Storage Capacity:**\\n```javascript\\n// Cookies - very limited (4KB total per domain)\\nconst largeData = 'x'.repeat(5000); // This would exceed cookie limit\\n\\n// localStorage/sessionStorage - much larger capacity\\nconst largeData = JSON.stringify(Array(1000).fill({\\n  id: Math.random(),\\n  data: 'large dataset'\\n})); // This works fine\\nlocalStorage.setItem('bigData', largeData);\\n```\\n\\n**4. API Differences:**\\n```javascript\\n// Cookies - string manipulation\\nfunction setCookie(name, value, days) {\\n  const expires = new Date();\\n  expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));\\n  document.cookie = `${name}=${value}; expires=${expires.toUTCString()}; path=/`;\\n}\\n\\nfunction getCookie(name) {\\n  const nameEQ = name + '=';\\n  const ca = document.cookie.split(';');\\n  for (let i = 0; i < ca.length; i++) {\\n    let c = ca[i];\\n    while (c.charAt(0) === ' ') c = c.substring(1, c.length);\\n    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);\\n  }\\n  return null;\\n}\\n\\n// localStorage/sessionStorage - simple key-value API\\nlocalStorage.setItem('key', 'value');\\nconst value = localStorage.getItem('key');\\nlocalStorage.removeItem('key');\\nlocalStorage.clear();\\n```\\n\\n**5. Security Features:**\\n```javascript\\n// Cookies - built-in security attributes\\ndocument.cookie = 'secure-data=value; secure; httponly; samesite=strict';\\n\\n// localStorage/sessionStorage - no built-in security\\n// Must implement encryption manually\\nfunction encryptData(data, key) {\\n  // Custom encryption implementation\\n  return btoa(data); // Simple base64 (not secure, just example)\\n}\\n\\nlocalStorage.setItem('sensitive', encryptData('secret', 'key'));\\n```\\n\\n**Use Case Recommendations:**\\n\\n**Use Cookies for:**\\n- Authentication tokens (server needs access)\\n- Session management\\n- User preferences that affect server rendering\\n- Small data that needs server access\\n\\n**Use localStorage for:**\\n- User preferences (theme, language)\\n- Application state\\n- Cached data\\n- Offline functionality\\n- Large datasets that don't need server access\\n\\n**Use sessionStorage for:**\\n- Temporary form data\\n- Single-session user state\\n- Tab-specific data\\n- Wizard/multi-step form progress\\n- Temporary caching"
    },
    {
      "id": 43,
      "question": "What is the main difference between localStorage and sessionStorage",
      "answer": "The main difference between localStorage and sessionStorage is their **scope and persistence**:\\n\\n**Key Differences:**\\n\\n**1. Persistence Duration:**\\n```javascript\\n// localStorage - persists until manually cleared\\nlocalStorage.setItem('user', 'john');\\n// Data survives: browser restart, computer restart, tab closing\\n// Only removed by: user clearing browser data, code calling clear(), or storage quota exceeded\\n\\n// sessionStorage - cleared when tab/window closes\\nsessionStorage.setItem('tempData', 'temporary');\\n// Data survives: page refresh, navigation within same tab\\n// Removed when: tab closes, window closes, browser crash\\n```\\n\\n**2. Scope and Sharing:**\\n```javascript\\n// localStorage - shared across all tabs/windows of same origin\\n// Tab 1\\nlocalStorage.setItem('sharedData', 'available everywhere');\\n\\n// Tab 2 (same domain)\\nconsole.log(localStorage.getItem('sharedData')); // 'available everywhere'\\n\\n// sessionStorage - isolated per tab/window\\n// Tab 1\\nsessionStorage.setItem('tabSpecific', 'only in this tab');\\n\\n// Tab 2 (same domain)\\nconsole.log(sessionStorage.getItem('tabSpecific')); // null\\n```\\n\\n**3. Practical Examples:**\\n\\n**localStorage Use Cases:**\\n```javascript\\n// User preferences that should persist\\nfunction saveTheme(theme) {\\n  localStorage.setItem('theme', theme);\\n}\\n\\n// Shopping cart that survives browser restart\\nfunction addToCart(item) {\\n  const cart = JSON.parse(localStorage.getItem('cart') || '[]');\\n  cart.push(item);\\n  localStorage.setItem('cart', JSON.stringify(cart));\\n}\\n\\n// User authentication token\\nfunction saveAuthToken(token) {\\n  localStorage.setItem('authToken', token);\\n}\\n\\n// Application settings\\nfunction saveSettings(settings) {\\n  localStorage.setItem('appSettings', JSON.stringify(settings));\\n}\\n```\\n\\n**sessionStorage Use Cases:**\\n```javascript\\n// Form data backup (in case of accidental refresh)\\nfunction backupFormData() {\\n  const formData = {\\n    name: document.getElementById('name').value,\\n    email: document.getElementById('email').value\\n  };\\n  sessionStorage.setItem('formBackup', JSON.stringify(formData));\\n}\\n\\n// Multi-step wizard progress\\nfunction saveWizardStep(step, data) {\\n  sessionStorage.setItem(`wizardStep${step}`, JSON.stringify(data));\\n}\\n\\n// Temporary session state\\nfunction setCurrentView(view) {\\n  sessionStorage.setItem('currentView', view);\\n}\\n\\n// Tab-specific user actions\\nfunction trackTabActivity(action) {\\n  const activities = JSON.parse(sessionStorage.getItem('tabActivities') || '[]');\\n  activities.push({ action, timestamp: Date.now() });\\n  sessionStorage.setItem('tabActivities', JSON.stringify(activities));\\n}\\n```\\n\\n**4. Cross-Tab Communication:**\\n```javascript\\n// localStorage can be used for cross-tab communication\\nwindow.addEventListener('storage', function(e) {\\n  if (e.key === 'userLoggedOut') {\\n    // Log out user in all tabs\\n    window.location.href = '/login';\\n  }\\n});\\n\\n// Trigger logout in all tabs\\nfunction logoutAllTabs() {\\n  localStorage.setItem('userLoggedOut', Date.now());\\n  localStorage.removeItem('userLoggedOut'); // Clean up\\n}\\n\\n// sessionStorage cannot be used for cross-tab communication\\n// Each tab has its own isolated sessionStorage\\n```\\n\\n**5. Memory and Performance:**\\n```javascript\\n// localStorage - data stays in memory and disk\\n// Good for: long-term storage, user preferences\\n// Watch out for: storage quota limits\\n\\n// sessionStorage - typically faster access\\n// Good for: temporary data, session-specific state\\n// Automatically cleaned up when tab closes\\n```\\n\\n**Decision Matrix:**\\n\\n| Use Case | localStorage | sessionStorage |\\n|----------|--------------|----------------|\\n| User preferences | ‚úÖ | ‚ùå |\\n| Authentication tokens | ‚úÖ | ‚ùå |\\n| Shopping cart | ‚úÖ | ‚ùå |\\n| Form backup | ‚ùå | ‚úÖ |\\n| Wizard steps | ‚ùå | ‚úÖ |\\n| Tab-specific state | ‚ùå | ‚úÖ |\\n| Cross-tab sharing | ‚úÖ | ‚ùå |\\n| Temporary caching | ‚ùå | ‚úÖ |\\n| Long-term storage | ‚úÖ | ‚ùå |"
    },
    {
      "id": 49,
      "question": "What is eval",
      "answer": "The `eval()` function evaluates JavaScript code represented as a string. The string can be a JavaScript expression, statement, or sequence of statements.\n\n**Example:**\n```javascript\nconsole.log(eval(\"1 + 2\")); // 3\n```\n\n**Key Points:**\n- Use with caution: `eval()` can execute arbitrary code and is a security risk.\n- Avoid using `eval()` when possible; prefer safer alternatives.\n- Variables and functions declared inside `eval()` are created in the current scope."
    },
    {
      "id": 50,
      "question": "What is the difference between window and document",
      "answer": "Here are the main differences between `window` and `document` in the browser:\n\n| Feature | window | document |\n|---------|--------|----------|\n| Description | Root-level object for the browser window/tab | Represents the web page (DOM) |\n| Access | Implicitly available | Accessed via `window.document` or `document` |\n| Methods | `alert()`, `confirm()`, `setTimeout()`, etc. | `getElementById()`, `createElement()`, etc. |\n| Properties | `document`, `location`, `history`, etc. | `body`, `forms`, `images`, etc. |\n\n**Summary:**\n- `window` is the global object for the browser environment.\n- `document` is a property of `window` and represents the DOM."
    },
    {
      "id": 51,
      "question": "How do you access history in JavaScript",
      "answer": "The `window.history` object contains the browser's session history. You can navigate back and forward using its methods.\n\n**Example:**\n```javascript\nfunction goBack() {\n  window.history.back();\n}\nfunction goForward() {\n  window.history.forward();\n}\n```\n\n**Key Points:**\n- `window.history.length` gives the number of entries in the history stack.\n- You can also use `history.go(n)` to move forward or backward by `n` steps.\n- The `window` prefix is optional."
    },
    {
      "id": 52,
      "question": "How do you detect caps lock key turned on or not",
      "answer": "You can use the `getModifierState()` method of keyboard or mouse events to detect if CapsLock is active.\n\n**Example:**\n```html\n<input type=\"password\" onmousedown=\"enterInput(event)\" />\n<p id=\"feedback\"></p>\n<script>\n  function enterInput(e) {\n    var flag = e.getModifierState(\"CapsLock\");\n    if (flag) {\n      document.getElementById(\"feedback\").innerHTML = \"CapsLock activated\";\n    } else {\n      document.getElementById(\"feedback\").innerHTML = \"CapsLock not activated\";\n    }\n  }\n<\/script>\n```\n\n**Key Points:**\n- Works with `keydown`, `keyup`, `mousedown`, and similar events.\n- Useful for providing user feedback in password fields."
    },
    {
      "id": 53,
      "question": "What is isNaN",
      "answer": "The `isNaN()` function determines whether a value is NaN (Not-a-Number). It returns `true` if the value is NaN or cannot be converted to a number, otherwise `false`.\n\n**Examples:**\n```javascript\nisNaN(\"Hello\"); // true\nisNaN(\"100\"); // false\nisNaN(NaN); // true\nisNaN(123); // false\n```\n\n**Key Points:**\n- `isNaN()` first tries to convert the value to a number.\n- Use `Number.isNaN()` for a stricter check (does not coerce values)."
    },
    {
      "id": 54,
      "question": "What are the differences between undeclared and undefined variables",
      "answer": "Here are the main differences between undeclared and undefined variables in JavaScript:\n\n| Feature | Undeclared | Undefined |\n|---------|------------|-----------|\n| Declaration | Not declared in the program | Declared but not assigned a value |\n| Access | ReferenceError if accessed | Returns `undefined` if accessed |\n| Example | `b; // ReferenceError` | `var a; a; // undefined` |\n\n**Example:**\n```javascript\nvar a;\na; // yields undefined\nb; // Throws ReferenceError: b is not defined\n```\n\n**Key Points:**\n- Undeclared variables cause runtime errors when accessed.\n- Undefined variables exist but have no value assigned."
    },
    {
      "id": 55,
      "question": "What are global variables",
      "answer": "Global variables are those that are available throughout the entire code, regardless of scope. In JavaScript, omitting the `var`, `let`, or `const` keyword when assigning a variable makes it global (not recommended).\n\n**Example:**\n```javascript\nmsg = \"Hello\"; // Becomes a global variable\nconsole.log(window.msg); // \"Hello\"\n```\n\n**Key Points:**\n- Global variables can be accessed from any function or block.\n- Overuse can lead to naming conflicts and bugs.\n- Best practice: always declare variables with `let`, `const`, or `var`."
    },
    {
      "id": 56,
      "question": "What are the problems with global variables",
      "answer": "The main problems with global variables are:\n- **Naming conflicts:** Local and global variables may have the same name, causing unexpected behavior.\n- **Difficult debugging:** Harder to track changes and bugs when many parts of code can modify globals.\n- **Testing issues:** Code relying on globals is harder to test in isolation.\n- **Namespace pollution:** Too many globals can clutter the global scope and cause maintenance issues.\n\n**Best Practice:**\n- Minimize use of global variables.\n- Use modules, closures, or IIFEs to encapsulate variables."
    },
    {
      "id": 57,
      "question": "What is NaN property",
      "answer": "The `NaN` property is a global property representing \"Not-a-Number\". It indicates that a value is not a legal number.\n\n**Examples:**\n```javascript\nMath.sqrt(-1); // NaN\nparseInt(\"Hello\"); // NaN\nconsole.log(typeof NaN); // \"number\"\n```\n\n**Key Points:**\n- `NaN` is of type `number`.\n- Any arithmetic operation with `NaN` results in `NaN`.\n- Use `isNaN()` or `Number.isNaN()` to check for NaN values."
    },
    {
      "id": 58,
      "question": "What is the purpose of isFinite function",
      "answer": "The `isFinite()` function determines whether a value is a finite, legal number. It returns `false` if the value is `Infinity`, `-Infinity`, or `NaN`, otherwise `true`.\n\n**Examples:**\n```javascript\nisFinite(Infinity); // false\nisFinite(NaN); // false\nisFinite(-Infinity); // false\nisFinite(100); // true\n```\n\n**Key Points:**\n- `isFinite()` converts the argument to a number before checking.\n- Use `Number.isFinite()` for a stricter check (no type coercion)."
    },
    {
      "id": 59,
      "question": "What is an event flow",
      "answer": "Event flow is the order in which event is received on the web page. When you click on an element that is nested in various other elements, before your click actually reaches its destination, or target element, it must trigger the click event for each of its parent elements first, starting at the top with the global window object.\n\nThere are two ways of event flow:\n1. **Top to Bottom (Event Capturing)**\n2. **Bottom to Top (Event Bubbling)**"
    },
    {
      "id": 60,
      "question": "What is event bubbling",
      "answer": "Event bubbling is a type of event propagation where the event first triggers on the innermost target element, and then successively triggers on the ancestors (parents) of the target element in the same nesting hierarchy till it reaches the outermost DOM element.\n\n```html\n<div id=\"parent\">\n  <button id=\"child\">Click me!</button>\n</div>\n```\n\n```javascript\ndocument.getElementById(\"parent\").addEventListener(\"click\", () => {\n  console.log(\"Parent clicked\");\n});\n\ndocument.getElementById(\"child\").addEventListener(\"click\", () => {\n  console.log(\"Child clicked\");\n});\n```\n\nIf you click the button, you'll see:\n1. \"Child clicked\"\n2. \"Parent clicked\""
    },
    {
      "id": 61,
      "question": "What is event capturing",
      "answer": "Event capturing is a type of event propagation where the event is first captured by the outermost element, and then successively triggers on the descendants (children) of the target element in the same nesting hierarchy till it reaches the innermost DOM element.\n\n```javascript\ndocument.getElementById(\"parent\").addEventListener(\"click\", () => {\n  console.log(\"Parent clicked\");\n}, true); // true enables capturing\n\ndocument.getElementById(\"child\").addEventListener(\"click\", () => {\n  console.log(\"Child clicked\");\n}, true);\n```\n\nIf you click the button, you'll see:\n1. \"Parent clicked\"\n2. \"Child clicked\""
    },
    {
      "id": 62,
      "question": "How do you submit a form using JavaScript",
      "answer": "You can submit a form using JavaScript in several ways:\n\n**1. Using the submit() method:**\n```javascript\ndocument.forms[\"myform\"].submit();\n```\n\n**2. Using form reference:**\n```javascript\ndocument.getElementById(\"myform\").submit();\n```\n\n**3. Using form validation before submit:**\n```javascript\nfunction submitForm() {\n  var form = document.getElementById(\"myform\");\n  if (validateForm()) {\n    form.submit();\n  }\n}\n```\n\n**Note:** The submit() method does not trigger the form's submit event, so any validation that depends on the submit event will not run."
    },
    {
      "id": 63,
      "question": "How do you find operating system details",
      "answer": "You can find operating system details using the `navigator.platform` property or the more modern `navigator.userAgentData` API:\n\n**Using navigator.platform (legacy):**\n```javascript\nconsole.log(navigator.platform); // \"Win32\", \"MacIntel\", \"Linux x86_64\", etc.\n```\n\n**Using User-Agent Client Hints API (modern):**\n```javascript\nif (navigator.userAgentData) {\n  navigator.userAgentData.getHighEntropyValues(['platform', 'platformVersion'])\n    .then(ua => {\n      console.log(ua.platform); // \"Windows\", \"macOS\", \"Linux\", etc.\n      console.log(ua.platformVersion); // Version details\n    });\n}\n```\n\n**Using user agent string (not recommended):**\n```javascript\nconst userAgent = navigator.userAgent;\nif (userAgent.includes('Windows')) {\n  console.log('Windows OS');\n} else if (userAgent.includes('Mac')) {\n  console.log('Mac OS');\n} else if (userAgent.includes('Linux')) {\n  console.log('Linux OS');\n}\n```"
    },
    {
      "id": 64,
      "question": "What is the difference between document load and DOMContentLoaded events",
      "answer": "The `DOMContentLoaded` and `load` events represent different stages in the page loading process:\n\n**DOMContentLoaded:**\n- Fires when the HTML document has been completely loaded and parsed\n- Does NOT wait for stylesheets, images, and subframes to finish loading\n- Fires earlier in the loading process\n\n```javascript\ndocument.addEventListener('DOMContentLoaded', () => {\n  console.log('DOM is ready!');\n});\n```\n\n**load:**\n- Fires when the entire page has finished loading\n- Waits for ALL resources (images, stylesheets, scripts, etc.) to load\n- Fires later in the loading process\n\n```javascript\nwindow.addEventListener('load', () => {\n  console.log('Everything is loaded!');\n});\n```\n\n**Timeline:**\n1. HTML parsing begins\n2. `DOMContentLoaded` fires (DOM ready)\n3. External resources continue loading\n4. `load` fires (everything ready)"
    },
    {
      "id": 65,
      "question": "What is the difference between native, host and user objects",
      "answer": "In JavaScript, objects can be categorized into three types:\n\n**Native Objects:**\n- Objects that are part of the JavaScript language specification (ECMAScript)\n- Available in any JavaScript environment\n- Examples: Object, Array, Function, String, Number, Boolean, Date, RegExp, Error, etc.\n\n```javascript\nvar arr = new Array(); // Native object\nvar obj = new Object(); // Native object\nvar date = new Date(); // Native object\n```\n\n**Host Objects:**\n- Objects provided by the host environment (browser, Node.js, etc.)\n- Not part of the JavaScript specification\n- Browser examples: window, document, location, history, XMLHttpRequest, etc.\n- Node.js examples: global, process, Buffer, etc.\n\n```javascript\nconsole.log(window); // Host object (browser)\nconsole.log(document); // Host object (browser)\n```\n\n**User Objects:**\n- Objects created by the developer/user\n- Custom objects defined in your code\n\n```javascript\nvar person = { name: 'John', age: 30 }; // User object\nfunction Car() { this.brand = 'Toyota'; } // User object constructor\n```"
    },
    {
      "id": 66,
      "question": "What are the tools or techniques used for debugging JavaScript code",
      "answer": "There are several tools and techniques for debugging JavaScript code:\n\n**Browser Developer Tools:**\n- Chrome DevTools, Firefox Developer Tools, Safari Web Inspector\n- Features: Console, Sources/Debugger, Network, Performance tabs\n\n**Debugging Techniques:**\n\n**1. Console methods:**\n```javascript\nconsole.log('Debug info');\nconsole.error('Error message');\nconsole.warn('Warning message');\nconsole.table(arrayOrObject);\nconsole.trace(); // Stack trace\n```\n\n**2. Debugger statement:**\n```javascript\nfunction myFunction() {\n  debugger; // Execution will pause here\n  // ... rest of code\n}\n```\n\n**3. Breakpoints:**\n- Set breakpoints in browser DevTools\n- Conditional breakpoints\n- Logpoints (log without stopping)\n\n**4. Error handling:**\n```javascript\ntry {\n  // risky code\n} catch (error) {\n  console.error('Error:', error);\n}\n```\n\n**External Tools:**\n- Visual Studio Code debugger\n- WebStorm debugger\n- Browser extensions\n- Linting tools (ESLint)\n- Performance profiling tools"
    },
    {
      "id": 67,
      "question": "What are the pros and cons of promises over callbacks",
      "answer": "**Promises vs Callbacks comparison:**\n\n**Pros of Promises:**\n\n**1. Avoid Callback Hell:**\n```javascript\n// Callback hell\ngetData(function(a) {\n  getMoreData(a, function(b) {\n    getMoreData(b, function(c) {\n      // nested callbacks...\n    });\n  });\n});\n\n// Promise chaining\ngetData()\n  .then(a => getMoreData(a))\n  .then(b => getMoreData(b))\n  .then(c => {\n    // clean chain\n  });\n```\n\n**2. Better Error Handling:**\n```javascript\n// Promises - single catch for all errors\ngetData()\n  .then(processData)\n  .then(saveData)\n  .catch(handleError); // Catches any error in the chain\n```\n\n**3. Better Composition:**\n- `Promise.all()`, `Promise.race()`, `Promise.allSettled()`\n- Easier to combine multiple async operations\n\n**4. Immutable:**\n- Once resolved/rejected, state cannot change\n- Can be passed around safely\n\n**Cons of Promises:**\n\n**1. Slightly More Complex:**\n- Additional learning curve\n- More overhead for simple cases\n\n**2. Not Cancellable:**\n- Cannot cancel a promise once started\n- Callbacks can be more easily abandoned\n\n**3. Browser Support:**\n- Older browsers need polyfills\n- Callbacks work everywhere\n\n**Overall:** Promises provide cleaner, more maintainable code for complex async operations, while callbacks might be simpler for basic use cases."
    },
    {
      "id": 68,
      "question": "What is the difference between an attribute and a property",
      "answer": "**Attributes** and **Properties** are related but distinct concepts in the DOM:\n\n**Attributes:**\n- Defined in HTML markup\n- Always strings\n- Represent the initial state\n- Accessed via `getAttribute()`, `setAttribute()`, `hasAttribute()`, `removeAttribute()`\n\n**Properties:**\n- JavaScript object properties of DOM elements\n- Can be any JavaScript type\n- Represent the current state\n- Accessed via dot notation or bracket notation\n\n**Examples:**\n\n```html\n<input id=\"myInput\" type=\"text\" value=\"Hello\" />\n```\n\n```javascript\nconst input = document.getElementById('myInput');\n\n// Attributes (strings, initial values)\nconsole.log(input.getAttribute('value')); // \"Hello\"\nconsole.log(input.getAttribute('type'));  // \"text\"\n\n// Properties (current values, various types)\nconsole.log(input.value); // \"Hello\" (but changes as user types)\nconsole.log(input.type);  // \"text\"\n\n// After user types \"World\":\nconsole.log(input.getAttribute('value')); // Still \"Hello\" (initial)\nconsole.log(input.value); // \"World\" (current)\n\n// Boolean example\ninput.disabled = true;\nconsole.log(input.disabled); // true (boolean property)\nconsole.log(input.getAttribute('disabled')); // \"\" (string attribute)\n```\n\n**Key Differences:**\n- Attributes reflect HTML, properties reflect current DOM state\n- Properties are \"live\", attributes are often static\n- Some properties have no corresponding attributes\n- Type conversion: attributes are always strings, properties can be any type"
    },
    {
      "id": 69,
      "question": "What is same-origin policy",
      "answer": "The same-origin policy is a critical security mechanism implemented by web browsers that restricts how a document or script loaded from one origin can interact with resources from another origin.\n\n**What defines an \"origin\"?**\nTwo URLs have the same origin if they have:\n1. Same protocol (http/https)\n2. Same domain/hostname\n3. Same port\n\n**Examples:**\n```\nURL: https://example.com:443/page1\nOrigin: https://example.com:443\n\n‚úÖ Same origin: https://example.com:443/page2\n‚ùå Different origin: http://example.com:443 (different protocol)\n‚ùå Different origin: https://sub.example.com:443 (different domain)\n‚ùå Different origin: https://example.com:8080 (different port)\n```\n\n**What's restricted:**\n- AJAX requests to different origins\n- Access to DOM elements from different origins\n- Reading cookies, localStorage from different origins\n- Access to iframe content from different origins\n\n**Workarounds:**\n1. **CORS (Cross-Origin Resource Sharing):**\n```javascript\n// Server sets headers to allow cross-origin requests\nAccess-Control-Allow-Origin: https://example.com\n```\n\n2. **JSONP (JSON with Padding):**\n```javascript\n// Uses script tags to bypass same-origin policy\n<script src=\"https://api.example.com/data?callback=handleData\"></script>\n```\n\n3. **Proxy server:** Route requests through same-origin proxy\n\n4. **postMessage API:** For iframe communication\n```javascript\nwindow.postMessage('Hello', 'https://example.com');\n```\n\n**Purpose:** Prevents malicious scripts from accessing sensitive data from other websites."
    },
    {
      "id": 70,
      "question": "What is the purpose of void 0",
      "answer": "`void 0` is a way to obtain the `undefined` value in JavaScript. The `void` operator evaluates any expression and returns `undefined`.\n\n**Why use `void 0` instead of `undefined`?**\n\n**Historical Context:**\nIn older JavaScript versions (before ES5), `undefined` was not a reserved keyword and could be overwritten:\n\n```javascript\n// This was possible in old JavaScript!\nundefined = \"not undefined anymore\";\nconsole.log(undefined); // \"not undefined anymore\"\n\n// But void 0 always returns true undefined\nconsole.log(void 0); // undefined (always reliable)\n```\n\n**Modern Usage:**\n```javascript\n// These are equivalent:\nvar a;\nconsole.log(a === undefined); // true\nconsole.log(a === void 0);    // true\n\n// Common patterns:\nif (typeof myVar === 'undefined') { /* ... */ }\nif (myVar === void 0) { /* ... */ }\n\n// In ternary operators:\nvar result = value !== void 0 ? value : defaultValue;\n```\n\n**Benefits:**\n- **Shorter:** `void 0` is shorter than `undefined`\n- **Reliable:** Always returns true undefined\n- **Minification:** Better for code minification\n- **Performance:** Slightly faster (no variable lookup)\n\n**Modern JavaScript:**\nSince ES5, `undefined` is read-only in the global scope, so `void 0` is less critical but still used for:\n- Legacy code compatibility\n- Minification benefits\n- Habit from older JavaScript development"
    },
    {
      "id": 71,
      "question": "What is the use of setTimeout",
      "answer": "`setTimeout` is a JavaScript function that executes a function or code snippet after a specified delay (in milliseconds).\n\n**Syntax:**\n```javascript\nsetTimeout(function, delay, param1, param2, ...)\nsetTimeout(code, delay)\n```\n\n**Basic Examples:**\n```javascript\n// Execute after 2 seconds\nsetTimeout(() => {\n  console.log('Hello after 2 seconds!');\n}, 2000);\n\n// With parameters\nsetTimeout((name, age) => {\n  console.log(`${name} is ${age} years old`);\n}, 1000, 'John', 25);\n\n// Store timeout ID for cancellation\nconst timeoutId = setTimeout(() => {\n  console.log('This might not run');\n}, 5000);\n\n// Cancel the timeout\nclearTimeout(timeoutId);\n```\n\n**Common Use Cases:**\n\n**1. Delaying execution:**\n```javascript\nfunction showMessage() {\n  setTimeout(() => {\n    alert('Welcome!');\n  }, 1000);\n}\n```\n\n**2. Debouncing:**\n```javascript\nlet debounceTimer;\nfunction debounce(func, delay) {\n  clearTimeout(debounceTimer);\n  debounceTimer = setTimeout(func, delay);\n}\n\n// Usage: debounce search as user types\ninput.addEventListener('input', () => {\n  debounce(() => {\n    performSearch(input.value);\n  }, 300);\n});\n```\n\n**3. Animation delays:**\n```javascript\nfunction animateSequence() {\n  element.classList.add('fade-in');\n  \n  setTimeout(() => {\n    element.classList.add('slide-up');\n  }, 500);\n  \n  setTimeout(() => {\n    element.classList.add('complete');\n  }, 1000);\n}\n```\n\n**Important Notes:**\n- Minimum delay is typically 4ms in browsers\n- Not guaranteed to execute at exact time (depends on call stack)\n- Returns a timeout ID that can be used with `clearTimeout()`\n- Runs asynchronously (non-blocking)"
    },
    {
      "id": 72,
      "question": "What is the use of setInterval",
      "answer": "`setInterval` is a JavaScript function that repeatedly executes a function or code snippet at specified intervals (in milliseconds).\n\n**Syntax:**\n```javascript\nsetInterval(function, delay, param1, param2, ...)\nsetInterval(code, delay)\n```\n\n**Basic Examples:**\n```javascript\n// Execute every 2 seconds\nconst intervalId = setInterval(() => {\n  console.log('This runs every 2 seconds');\n}, 2000);\n\n// With parameters\nsetInterval((message) => {\n  console.log(message);\n}, 1000, 'Tick!');\n\n// Stop the interval\nclearInterval(intervalId);\n```\n\n**Common Use Cases:**\n\n**1. Digital Clock:**\n```javascript\nfunction updateClock() {\n  const now = new Date();\n  document.getElementById('clock').textContent = now.toLocaleTimeString();\n}\n\n// Update every second\nsetInterval(updateClock, 1000);\n```\n\n**2. Auto-save functionality:**\n```javascript\nfunction autoSave() {\n  const data = getFormData();\n  saveToLocalStorage(data);\n  console.log('Auto-saved at:', new Date().toLocaleTimeString());\n}\n\n// Auto-save every 30 seconds\nconst autoSaveInterval = setInterval(autoSave, 30000);\n```\n\n**3. Progress updates:**\n```javascript\nlet progress = 0;\nconst progressInterval = setInterval(() => {\n  progress += 10;\n  updateProgressBar(progress);\n  \n  if (progress >= 100) {\n    clearInterval(progressInterval);\n    console.log('Progress complete!');\n  }\n}, 500);\n```\n\n**4. Polling for updates:**\n```javascript\nfunction checkForUpdates() {\n  fetch('/api/status')\n    .then(response => response.json())\n    .then(data => {\n      if (data.hasUpdate) {\n        showNotification('New update available!');\n      }\n    });\n}\n\n// Check every 5 minutes\nsetInterval(checkForUpdates, 5 * 60 * 1000);\n```\n\n**Important Notes:**\n- Returns an interval ID that can be used with `clearInterval()`\n- Continues until explicitly stopped or page unloads\n- Can cause performance issues if interval is too frequent\n- May drift over time due to execution delays\n\n**Best Practices:**\n- Always store the interval ID for cleanup\n- Clear intervals when no longer needed\n- Be mindful of performance with frequent intervals\n- Consider `requestAnimationFrame` for smooth animations instead"
    },
    {
      "id": 73,
      "question": "Why is JavaScript treated as Dynamic language",
      "answer": "JavaScript is considered a **dynamic language** because many operations that are typically performed at compile-time in static languages are performed at runtime in JavaScript.\n\n**Key Dynamic Features:**\n\n**1. Dynamic Typing:**\n```javascript\nlet variable = 42;        // number\nvariable = \"Hello\";       // now string\nvariable = true;          // now boolean\nvariable = { key: \"value\" }; // now object\n\n// No type declarations needed\nfunction add(a, b) {\n  return a + b; // Works with numbers, strings, etc.\n}\n```\n\n**2. Dynamic Property Addition/Removal:**\n```javascript\nconst obj = {};\n\n// Add properties dynamically\nobj.name = \"John\";\nobj[\"age\"] = 30;\nobj.greet = function() { return \"Hello!\"; };\n\n// Remove properties\ndelete obj.age;\n\nconsole.log(obj); // { name: \"John\", greet: [Function] }\n```\n\n**3. Dynamic Method Definition:**\n```javascript\nconst person = {\n  name: \"Alice\"\n};\n\n// Add methods at runtime\nperson.sayHello = function() {\n  return `Hello, I'm ${this.name}`;\n};\n\n// Modify existing methods\nif (someCondition) {\n  person.sayHello = function() {\n    return `Hi there, I'm ${this.name}!`;\n  };\n}\n```\n\n**4. Dynamic Code Execution:**\n```javascript\n// Execute code from strings\nconst code = \"console.log('Dynamic execution!')\";\neval(code); // Not recommended, but possible\n\n// Dynamic function creation\nconst dynamicFunction = new Function('a', 'b', 'return a + b');\nconsole.log(dynamicFunction(2, 3)); // 5\n```\n\n**5. Runtime Type Checking:**\n```javascript\nfunction processValue(value) {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  } else if (typeof value === 'number') {\n    return value * 2;\n  } else if (Array.isArray(value)) {\n    return value.length;\n  }\n  return null;\n}\n```\n\n**6. Prototype Modification:**\n```javascript\n// Modify built-in prototypes (not recommended in production)\nString.prototype.reverse = function() {\n  return this.split('').reverse().join('');\n};\n\nconsole.log(\"hello\".reverse()); // \"olleh\"\n```\n\n**Benefits:**\n- **Flexibility:** Easy to adapt and modify code at runtime\n- **Rapid Development:** Less boilerplate, faster prototyping\n- **Expressiveness:** Can write concise, powerful code\n\n**Drawbacks:**\n- **Runtime Errors:** Type errors caught at runtime, not compile-time\n- **Performance:** Dynamic features can be slower than static alternatives\n- **Debugging:** Harder to track issues in highly dynamic code\n\n**Comparison with Static Languages:**\n```javascript\n// JavaScript (Dynamic)\nlet value = getUserInput(); // Could be anything\nif (value.length) { /* ... */ } // Runtime check\n\n// TypeScript/Java (Static)\n// String value = getUserInput(); // Type declared\n// if (value.length() > 0) { /* ... */ } // Compile-time safety\n```\n\nThis dynamic nature makes JavaScript very flexible but requires careful programming to avoid runtime errors."
    },
    {
      "id": 74,
      "question": "What is a regular expression",
      "answer": "A **regular expression (regex)** is a sequence of characters that defines a search pattern. In JavaScript, regex is used for pattern matching, searching, and replacing text within strings.\n\n**Creating Regular Expressions:**\n\n**1. Literal notation:**\n```javascript\nconst regex1 = /pattern/flags;\nconst regex2 = /hello/i; // Case-insensitive\n```\n\n**2. Constructor function:**\n```javascript\nconst regex3 = new RegExp('pattern', 'flags');\nconst regex4 = new RegExp('hello', 'i');\n```\n\n**Common Flags:**\n- `i` - Case-insensitive\n- `g` - Global (find all matches)\n- `m` - Multiline\n- `s` - Dot matches newlines\n- `u` - Unicode\n- `y` - Sticky\n\n**Basic Patterns:**\n```javascript\n// Literal characters\n/hello/          // Matches \"hello\"\n\n// Special characters\n/\\d/             // Matches any digit (0-9)\n/\\w/             // Matches any word character (a-z, A-Z, 0-9, _)\n/\\s/             // Matches any whitespace\n/./              // Matches any character except newline\n\n// Character classes\n/[abc]/          // Matches 'a', 'b', or 'c'\n/[a-z]/          // Matches any lowercase letter\n/[^abc]/         // Matches anything except 'a', 'b', or 'c'\n\n// Quantifiers\n/a+/             // One or more 'a'\n/a*/             // Zero or more 'a'\n/a?/             // Zero or one 'a'\n/a{2,4}/         // 2 to 4 'a's\n/a{3}/           // Exactly 3 'a's\n\n// Anchors\n/^hello/         // Starts with \"hello\"\n/world$/         // Ends with \"world\"\n```\n\n**Common Methods:**\n\n**1. test() - Check if pattern exists:**\n```javascript\nconst emailRegex = /^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$/;\nconsole.log(emailRegex.test('user@example.com')); // true\nconsole.log(emailRegex.test('invalid-email'));    // false\n```\n\n**2. match() - Find matches:**\n```javascript\nconst text = \"Call me at 123-456-7890 or 987-654-3210\";\nconst phoneRegex = /\\d{3}-\\d{3}-\\d{4}/g;\nconsole.log(text.match(phoneRegex)); // [\"123-456-7890\", \"987-654-3210\"]\n```\n\n**3. replace() - Replace matches:**\n```javascript\nconst text = \"Hello World\";\nconst result = text.replace(/[aeiou]/gi, '*'); // Replace vowels\nconsole.log(result); // \"H*ll* W*rld\"\n```\n\n**4. search() - Find position:**\n```javascript\nconst text = \"JavaScript is awesome\";\nconsole.log(text.search(/script/i)); // 4 (position of \"Script\")\n```\n\n**5. split() - Split string:**\n```javascript\nconst text = \"apple,banana;orange:grape\";\nconst fruits = text.split(/[,;:]/);\nconsole.log(fruits); // [\"apple\", \"banana\", \"orange\", \"grape\"]\n```\n\n**Practical Examples:**\n\n**Email validation:**\n```javascript\nfunction isValidEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n```\n\n**Extract numbers:**\n```javascript\nconst text = \"Price: $25.99, Tax: $3.50\";\nconst numbers = text.match(/\\d+\\.\\d+/g);\nconsole.log(numbers); // [\"25.99\", \"3.50\"]\n```\n\n**Format phone numbers:**\n```javascript\nfunction formatPhone(phone) {\n  const cleaned = phone.replace(/\\D/g, ''); // Remove non-digits\n  const match = cleaned.match(/^(\\d{3})(\\d{3})(\\d{4})$/);\n  if (match) {\n    return `(${match[1]}) ${match[2]}-${match[3]}`;\n  }\n  return phone;\n}\n\nconsole.log(formatPhone('1234567890')); // \"(123) 456-7890\"\n```\n\nRegular expressions are powerful tools for text processing, validation, and data extraction in JavaScript."
    },
    {
      "id": 75,
      "question": "What are the string methods available in Regular expression",
      "answer": "JavaScript provides several string methods that work with regular expressions for pattern matching and text manipulation:\n\n**1. search() - Find position of first match**\n```javascript\nconst text = \"JavaScript is awesome\";\n\n// Returns index of first match, -1 if not found\nconsole.log(text.search(/script/i));      // 4\nconsole.log(text.search(/python/i));      // -1\nconsole.log(text.search(/is/));           // 11\n```\n\n**2. match() - Extract matches**\n```javascript\nconst text = \"Contact: john@email.com or jane@test.org\";\n\n// Without global flag - returns first match with details\nconst singleMatch = text.match(/\\w+@\\w+\\.\\w+/);\nconsole.log(singleMatch);\n// [\"john@email.com\", index: 9, input: \"Contact: john@email.com or jane@test.org\", groups: undefined]\n\n// With global flag - returns all matches\nconst allMatches = text.match(/\\w+@\\w+\\.\\w+/g);\nconsole.log(allMatches); // [\"john@email.com\", \"jane@test.org\"]\n```\n\n**3. matchAll() - Get iterator of all matches with details**\n```javascript\nconst text = \"Price: $25.99, Tax: $3.50, Total: $29.49\";\nconst regex = /\\$(\\d+)\\.(\\d+)/g;\n\n// Returns iterator with full match details\nfor (const match of text.matchAll(regex)) {\n  console.log(`Full: ${match[0]}, Dollars: ${match[1]}, Cents: ${match[2]}`);\n}\n// Full: $25.99, Dollars: 25, Cents: 99\n// Full: $3.50, Dollars: 3, Cents: 50\n// Full: $29.49, Dollars: 29, Cents: 49\n```\n\n**4. replace() - Replace matches**\n```javascript\nconst text = \"Hello World! Hello Universe!\";\n\n// Replace first match\nconst result1 = text.replace(/Hello/, \"Hi\");\nconsole.log(result1); // \"Hi World! Hello Universe!\"\n\n// Replace all matches (global flag)\nconst result2 = text.replace(/Hello/g, \"Hi\");\nconsole.log(result2); // \"Hi World! Hi Universe!\"\n\n// Using capture groups and replacement function\nconst phoneText = \"Call 123-456-7890 or 987-654-3210\";\nconst formatted = phoneText.replace(/(\\d{3})-(\\d{3})-(\\d{4})/g, '($1) $2-$3');\nconsole.log(formatted); // \"Call (123) 456-7890 or (987) 654-3210\"\n\n// Using function for complex replacement\nconst result3 = \"temperature: 25C, 30C, 15C\".replace(/\\d+C/g, (match) => {\n  const celsius = parseInt(match);\n  const fahrenheit = (celsius * 9/5) + 32;\n  return `${fahrenheit}F`;\n});\nconsole.log(result3); // \"temperature: 77F, 86F, 59F\"\n```\n\n**5. replaceAll() - Replace all matches (ES2021)**\n```javascript\nconst text = \"Hello World! Hello Universe!\";\n\n// Replace all occurrences (no need for global flag)\nconst result = text.replaceAll(/Hello/g, \"Hi\");\nconsole.log(result); // \"Hi World! Hi Universe!\"\n\n// Note: Must use global flag with regex, or use string\nconst result2 = text.replaceAll(\"Hello\", \"Hi\"); // Works with strings\n```\n\n**6. split() - Split string by pattern**\n```javascript\nconst data = \"apple,banana;orange:grape|cherry\";\n\n// Split by multiple delimiters\nconst fruits = data.split(/[,;:|]/);\nconsole.log(fruits); // [\"apple\", \"banana\", \"orange\", \"grape\", \"cherry\"]\n\n// Split with limit\nconst limited = data.split(/[,;:|]/, 3);\nconsole.log(limited); // [\"apple\", \"banana\", \"orange\"]\n\n// Split by whitespace\nconst sentence = \"  Hello    world   JavaScript  \";\nconst words = sentence.split(/\\s+/).filter(word => word.length > 0);\nconsole.log(words); // [\"Hello\", \"world\", \"JavaScript\"]\n```\n\n**Practical Examples:**\n\n**Extract all URLs:**\n```javascript\nconst text = \"Visit https://example.com or http://test.org for more info\";\nconst urls = text.match(/https?:\\/\\/[\\w.-]+/g);\nconsole.log(urls); // [\"https://example.com\", \"http://test.org\"]\n```\n\n**Clean and format text:**\n```javascript\nfunction cleanText(text) {\n  return text\n    .replace(/\\s+/g, ' ')           // Multiple spaces to single\n    .replace(/^\\s+|\\s+$/g, '')      // Trim whitespace\n    .replace(/[^\\w\\s.-]/g, '');     // Remove special characters\n}\n\nconsole.log(cleanText(\"  Hello!!!   World???  \")); // \"Hello World\"\n```\n\n**Validate and extract data:**\n```javascript\nfunction extractPhoneNumbers(text) {\n  const phoneRegex = /\\(?\\d{3}\\)?[-\\s]?\\d{3}[-\\s]?\\d{4}/g;\n  return text.match(phoneRegex) || [];\n}\n\nconst contact = \"Call (555) 123-4567 or 555.987.6543 for help\";\nconsole.log(extractPhoneNumbers(contact)); // [\"(555) 123-4567\", \"555.987.6543\"]\n```\n\nThese methods provide powerful text processing capabilities when combined with regular expressions."
    },
    {
      "id": 76,
      "question": "What is a cookie in a website",
      "answer": "**Cookies** are small pieces of data stored on the user's device (browser) by websites. They serve as a memory mechanism for web applications to recall stateful information about the user or their interactions with the website.\n\n**Key Characteristics of Cookies:**\n\n1. **Size Limitation**: Cookies are limited to about 4KB per domain.\n2. **Storage Location**: Stored on the client-side (user's browser).\n3. **Sent with Requests**: Automatically sent with every HTTP request to the same domain.\n4. **Domain Specific**: Can only be accessed by the domain that created them (unless configured otherwise).\n\n**Creating Cookies in JavaScript:**\n\n```javascript\n// Setting a basic cookie\ndocument.cookie = \"username=John\";  \n\n// With expiration date (required for persistence)\ndocument.cookie = \"username=John; expires=Thu, 18 Dec 2023 12:00:00 UTC\"; \n\n// With path specification\ndocument.cookie = \"username=John; path=/profile\"; \n\n// With domain specification\ndocument.cookie = \"username=John; domain=example.com\";\n\n// Setting a secure cookie (only sent over HTTPS)\ndocument.cookie = \"username=John; secure\";\n\n// Setting HttpOnly flag (inaccessible to JavaScript)\n// Note: Can only be set server-side\n```\n\n**Reading Cookies:**\n\n```javascript\n// Reading all cookies\nconst allCookies = document.cookie;\nconsole.log(allCookies); // \"username=John; theme=dark; sessionId=abc123\"\n\n// Parsing cookie value\nfunction getCookie(name) {\n  const cookieArr = document.cookie.split(\";\");\n  \n  for(let i = 0; i < cookieArr.length; i++) {\n    const cookiePair = cookieArr[i].trim().split(\"=\");\n    \n    if(cookiePair[0] === name) {\n      return decodeURIComponent(cookiePair[1]);\n    }\n  }\n  \n  return null;\n}\n\nconst username = getCookie(\"username\");\nconsole.log(username); // \"John\"\n```\n\n**Updating Cookies:**\n\n```javascript\n// Update by setting with the same name\ndocument.cookie = \"username=Jane\"; // Overwrites the \"username\" cookie\n```\n\n**Deleting Cookies:**\n\n```javascript\n// Delete by setting an expired date\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\";\n```\n\n**Cookie Attributes:**\n\n1. **expires/max-age**: Defines when the cookie expires\n   ```javascript\n   document.cookie = \"name=value; expires=Thu, 18 Dec 2023 12:00:00 UTC\";\n   document.cookie = \"name=value; max-age=31536000\"; // 1 year in seconds\n   ```\n\n2. **path**: Restricts cookie to a specific path\n   ```javascript\n   document.cookie = \"name=value; path=/products\";\n   ```\n\n3. **domain**: Specifies which domains can access the cookie\n   ```javascript\n   document.cookie = \"name=value; domain=.example.com\"; // Accessible to subdomains\n   ```\n\n4. **secure**: Only transmitted over HTTPS connections\n   ```javascript\n   document.cookie = \"name=value; secure\";\n   ```\n\n5. **HttpOnly**: Prevents JavaScript access to cookie (set by server)\n\n6. **SameSite**: Controls how cookies are sent with cross-origin requests\n   ```javascript\n   document.cookie = \"name=value; SameSite=Strict\";\n   document.cookie = \"name=value; SameSite=Lax\"; // Default in modern browsers\n   document.cookie = \"name=value; SameSite=None; Secure\"; // Cross-site cookies\n   ```\n\n**Common Use Cases:**\n\n1. **Session Management**: Storing session IDs to maintain logged-in state\n2. **Personalization**: Storing user preferences (e.g., theme, language)\n3. **Tracking**: Analyzing user behavior and site usage patterns\n4. **Shopping Carts**: Remembering items in a user's cart\n\n**Privacy and Regulations:**\n\nMany jurisdictions have regulations regarding cookies and user tracking:\n\n- **GDPR** (EU): Requires explicit consent for non-essential cookies\n- **CCPA** (California): Requires disclosure and opt-out options\n- **Cookie Consent Banners**: Commonly used to comply with regulations\n\n```javascript\n// Example of a simple cookie consent function\nfunction setCookieConsent(hasConsent) {\n  if (hasConsent) {\n    document.cookie = \"cookieConsent=true; max-age=31536000; path=/\";\n    enableAnalyticsCookies();\n  } else {\n    document.cookie = \"cookieConsent=false; max-age=31536000; path=/\";\n    disableAnalyticsCookies();\n  }\n}\n```\n\n**Limitations and Alternatives:**\n\n1. **Size**: Limited to ~4KB\n2. **Security**: Vulnerable to XSS attacks if not properly secured\n3. **Alternatives**:\n   - **Web Storage** (localStorage, sessionStorage): Larger storage capacity\n   - **IndexedDB**: For structured data storage\n   - **Web SQL**: SQL-based storage (deprecated)\n   - **Cache API**: For caching resources\n\nCookies remain an essential tool for stateful interactions on the web, despite newer storage technologies being available."
    },
    {
      "id": 77,
      "question": "Why do you need a Cookie",
      "answer": "**Why Cookies Are Needed in Web Development**\n\nCookies serve essential functions in modern web applications that would otherwise be impossible due to HTTP's stateless nature. Here are the key reasons why cookies are necessary:\n\n**1. Session Management**\n\nThe most fundamental reason for cookies is maintaining user sessions across page loads:\n\n```javascript\n// Server generates a session ID when user logs in\ndocument.cookie = \"sessionId=a3fWa; max-age=3600; path=/\";\n\n// On subsequent requests, the server can identify the user\n// through this sessionId cookie sent automatically with each request\n```\n\nWithout cookies, users would need to re-authenticate on every page load or action, creating a frustrating user experience.\n\n**2. Personalization**\n\nCookies enable websites to remember user preferences and settings:\n\n```javascript\n// Store user preferences\ndocument.cookie = \"theme=dark; max-age=31536000\"; // Persist for a year\ndocument.cookie = \"fontSize=large; max-age=31536000\";\ndocument.cookie = \"region=europe; max-age=31536000\";\n\n// Later retrieve and apply these settings\nconst theme = getCookie(\"theme\");\nif (theme === \"dark\") {\n  document.body.classList.add(\"dark-mode\");\n}\n```\n\nThis personalization creates tailored experiences without requiring users to reconfigure settings on each visit.\n\n**3. Shopping Carts & E-commerce**\n\nE-commerce sites use cookies to maintain shopping cart contents across sessions:\n\n```javascript\n// Add item to cart\nfunction addToCart(productId, quantity) {\n  let cart = getCookie(\"cart\");\n  cart = cart ? JSON.parse(cart) : {};\n  \n  cart[productId] = (cart[productId] || 0) + quantity;\n  \n  document.cookie = `cart=${JSON.stringify(cart)}; path=/; max-age=86400`;\n}\n```\n\nThis allows users to add items, navigate away, and return with their selections intact.\n\n**4. Authentication State**\n\nCookies maintain authentication state securely:\n\n```javascript\n// Server sets this after successful authentication\ndocument.cookie = \"authToken=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...; HttpOnly; Secure; SameSite=Strict\";\n```\n\nThe HttpOnly flag prevents JavaScript access, protecting against XSS attacks, while Secure ensures transmission only over HTTPS.\n\n**5. Analytics and Tracking**\n\nCookies enable site owners to understand user behavior:\n\n```javascript\n// Set unique visitor ID\nif (!getCookie(\"visitorId\")) {\n  const uniqueId = generateUniqueId();\n  document.cookie = `visitorId=${uniqueId}; max-age=31536000`;\n}\n\n// Track page views\nfunction trackPageView() {\n  const visitorId = getCookie(\"visitorId\");\n  const page = window.location.pathname;\n  \n  // Send to analytics server\n  navigator.sendBeacon(\"/analytics\", JSON.stringify({\n    visitorId,\n    page,\n    timestamp: new Date().toISOString()\n  }));\n}\n```\n\n**6. A/B Testing**\n\nCookies are crucial for consistent A/B test experiences:\n\n```javascript\n// Assign user to test variant\nfunction assignVariant() {\n  if (!getCookie(\"testVariant\")) {\n    const variant = Math.random() > 0.5 ? \"A\" : \"B\";\n    document.cookie = `testVariant=${variant}; max-age=2592000`; // 30 days\n    return variant;\n  }\n  return getCookie(\"testVariant\");\n}\n\nconst variant = assignVariant();\nif (variant === \"B\") {\n  document.querySelector(\".hero\").style.backgroundColor = \"blue\";\n}\n```\n\nThis ensures users consistently see the same variant throughout their browsing session.\n\n**7. Cross-Site Request Forgery (CSRF) Protection**\n\nCookies help protect against CSRF attacks:\n\n```javascript\n// Server generates token and sets as cookie\ndocument.cookie = \"csrfToken=a1b2c3d4e5f6; HttpOnly; SameSite=Lax\";\n\n// JavaScript retrieves token and adds to form submissions\nconst form = document.querySelector(\"form\");\nconst csrfInput = document.createElement(\"input\");\ncsrfInput.type = \"hidden\";\ncsrfInput.name = \"_csrf\";\ncsrfInput.value = getCookie(\"csrfToken\");\nform.appendChild(csrfInput);\n```\n\n**8. State Persistence in RESTful Services**\n\nRESTful APIs are stateless by design, but cookies provide a way to maintain state across requests:\n\n```javascript\n// Server sets cookies after initial API authentication\n// Subsequent API calls include these cookies automatically\nfetch('/api/user/profile', {\n  credentials: 'include' // Ensures cookies are sent\n})\n.then(response => response.json())\n.then(data => console.log(data));\n```\n\n**9. Language/Locale Preferences**\n\nRemembering language preferences improves user experience:\n\n```javascript\n// Set language preference\nfunction setLanguage(lang) {\n  document.cookie = `language=${lang}; path=/; max-age=31536000`;\n  document.documentElement.lang = lang;\n}\n\n// Apply stored language preference on page load\nconst savedLang = getCookie(\"language\") || navigator.language.split('-')[0] || \"en\";\ndocument.documentElement.lang = savedLang;\n```\n\n**10. Rate Limiting & Security**\n\nCookies help implement rate limiting and other security measures:\n\n```javascript\n// Server can track login attempts using cookies\ndocument.cookie = \"loginAttempts=1; max-age=3600\";\n\n// Increment with each failed attempt\nfunction incrementLoginAttempts() {\n  const attempts = parseInt(getCookie(\"loginAttempts\") || \"0\");\n  document.cookie = `loginAttempts=${attempts + 1}; max-age=3600`;\n  \n  // If too many attempts, lock account temporarily\n  if (attempts >= 5) {\n    document.cookie = \"accountLocked=true; max-age=1800\"; // 30 minutes\n  }\n}\n```\n\n**Alternatives to Cookies:**\n\nWhile cookies are essential, they do have alternatives for specific use cases:\n\n1. **Web Storage (localStorage/sessionStorage)** - For client-side storage without automatic transmission to server\n2. **IndexedDB** - For larger structured data storage needs\n3. **JWT in Authorization headers** - For API authentication\n4. **URL parameters** - For passing temporary state (less secure)\n\nHowever, for maintaining state across HTTP requests securely and efficiently, cookies remain the most appropriate solution."
    },
    {
      "id": 78,
      "question": "What are the differences between cookie, local storage and session storage",
      "answer": "# Cookies vs. localStorage vs. sessionStorage\n\nThese three browser storage mechanisms serve similar purposes but differ in key aspects. Here's a comprehensive comparison:\n\n## üç™ Cookies\n\n**Definition**: Small pieces of data stored by the browser and sent to the server with every HTTP request.\n\n**Key Characteristics:**\n\n```javascript\n// Creating a cookie\ndocument.cookie = \"username=John; expires=Thu, 18 Dec 2025 12:00:00 UTC; path=/\";\n\n// Reading cookies\nconst cookies = document.cookie; // Returns all cookies as one string\n\n// Deleting a cookie\ndocument.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\";\n```\n\n- **Capacity**: ~4KB per cookie, typically limited to 20-50 cookies per domain\n- **Expiration**: Can set explicit expiration date; if not set, expires when the browser session ends\n- **Accessibility**: \n  - By default, accessible to all pages from the same domain\n  - Can restrict by path, domain, etc.\n  - Can be made HttpOnly (inaccessible to JavaScript)\n- **Server Communication**: Automatically sent to the server with every HTTP request via Cookie header\n- **API Complexity**: More complex API with string-based manipulation\n\n## üíæ localStorage\n\n**Definition**: Persistent client-side storage without expiration.\n\n**Key Characteristics:**\n\n```javascript\n// Storing data\nlocalStorage.setItem(\"username\", \"John\");\nlocalStorage.user = JSON.stringify({name: \"John\", role: \"admin\"});\n\n// Reading data\nconst username = localStorage.getItem(\"username\");\nconst user = JSON.parse(localStorage.user);\n\n// Removing data\nlocalStorage.removeItem(\"username\");\ndelete localStorage.user;\n\n// Clearing all data\nlocalStorage.clear();\n```\n\n- **Capacity**: ~5-10MB per domain\n- **Expiration**: Persists indefinitely until explicitly cleared\n- **Accessibility**: \n  - Available to any page from the same origin (protocol + domain + port)\n  - Not accessible across different domains/subdomains unless explicitly shared\n  - Always accessible to JavaScript\n- **Server Communication**: Never automatically sent to server\n- **API Complexity**: Simple key-value API with dedicated methods\n\n## ‚è±Ô∏è sessionStorage\n\n**Definition**: Similar to localStorage but limited to the current browser tab/window session.\n\n**Key Characteristics:**\n\n```javascript\n// Storing data\nsessionStorage.setItem(\"cartItems\", JSON.stringify([{id: 1, name: \"Product\"}]));\n\n// Reading data\nconst cartItems = JSON.parse(sessionStorage.getItem(\"cartItems\"));\n\n// Removing data\nsessionStorage.removeItem(\"cartItems\");\n\n// Clearing all data\nsessionStorage.clear();\n```\n\n- **Capacity**: ~5-10MB per domain\n- **Expiration**: Data cleared when the tab/window is closed\n- **Accessibility**: \n  - Limited to the exact tab/window where it was created\n  - Even separate tabs of the same site cannot access each other's sessionStorage\n  - Always accessible to JavaScript\n- **Server Communication**: Never automatically sent to server\n- **API Complexity**: Simple key-value API (identical to localStorage)\n\n## üìä Comparative Analysis\n\n### Storage Capacity\n\n```\nCookies:        ~4KB\nlocalStorage:   ~5-10MB\nsessionStorage: ~5-10MB\n```\n\n### Data Persistence\n\n```\nCookies:        Custom expiration or session-based\nlocalStorage:   Permanent until explicitly deleted\nsessionStorage: Tab/window session only\n```\n\n### Server Communication\n\n```\nCookies:        Sent with every HTTP request\nlocalStorage:   Never sent automatically\nsessionStorage: Never sent automatically\n```\n\n### Security Considerations\n\n**Cookies:**\n- Can be made secure (HTTPS only)\n- Can be HttpOnly (inaccessible to JavaScript)\n- Can have SameSite attribute to prevent CSRF\n- Vulnerable to CSRF if not protected\n\n```javascript\ndocument.cookie = \"sessionId=abc123; HttpOnly; Secure; SameSite=Strict\";\n```\n\n**localStorage/sessionStorage:**\n- Always accessible to JavaScript (XSS vulnerability)\n- Not automatically sent with requests (no CSRF risk)\n- Same-origin policy protection by default\n\n### Use Cases\n\n**Cookies are best for:**\n- Authentication tokens (with HttpOnly flag)\n- Server-side session management\n- Tracking user behavior across pages\n- Scenarios where data needs to be accessible both client and server-side\n\n**localStorage is best for:**\n- Persistent preferences/settings\n- Cached application data\n- Offline application data\n- Any data that should persist between sessions\n\n```javascript\n// Storing user preferences\nlocalStorage.setItem(\"theme\", \"dark\");\nlocalStorage.setItem(\"fontSize\", \"large\");\n\n// Storing cached API responses\nfunction cacheApiData(key, data, ttl) {\n  const item = {\n    data,\n    expiry: Date.now() + ttl\n  };\n  localStorage.setItem(key, JSON.stringify(item));\n}\n```\n\n**sessionStorage is best for:**\n- Form data during a multi-step process\n- Shopping cart during a session\n- Temporary user states that shouldn't persist between sessions\n- Per-tab settings in web applications\n\n```javascript\n// Storing form progress\nsessionStorage.setItem(\"registrationStep\", \"2\");\nsessionStorage.setItem(\"formData\", JSON.stringify({\n  name: \"John\",\n  email: \"john@example.com\"\n}));\n```\n\n### Performance Impact\n\n**Cookies:**\n- Increase network load (sent with every request)\n- Minimal impact on client-side performance\n\n**localStorage/sessionStorage:**\n- No impact on network traffic\n- Synchronous API can block the main thread with large operations\n\n```javascript\n// Potentially blocking operation with large data\nconst hugeData = localStorage.getItem(\"largeDataset\"); // Blocks UI thread\n\n// Better approach for large data\nsetTimeout(() => {\n  const hugeData = localStorage.getItem(\"largeDataset\");\n  processData(hugeData);\n}, 0);\n```\n\n## Advanced Usage Patterns\n\n### Storage Event Listening (localStorage)\n\n```javascript\n// This event fires in other tabs when localStorage changes\nwindow.addEventListener('storage', (event) => {\n  console.log(`Key ${event.key} changed from ${event.oldValue} to ${event.newValue}`);\n  \n  // Update UI based on the change\n  if (event.key === 'theme') {\n    applyTheme(event.newValue);\n  }\n});\n```\n\n### Storage Abstraction with Expiry Support\n\n```javascript\nconst storage = {\n  set(key, value, ttl = null) {\n    const item = {\n      value,\n      expiry: ttl ? Date.now() + ttl : null,\n    };\n    localStorage.setItem(key, JSON.stringify(item));\n  },\n  \n  get(key) {\n    const itemStr = localStorage.getItem(key);\n    if (!itemStr) return null;\n    \n    const item = JSON.parse(itemStr);\n    if (item.expiry && Date.now() > item.expiry) {\n      localStorage.removeItem(key);\n      return null;\n    }\n    \n    return item.value;\n  }\n};\n\n// Usage\nstorage.set('user', {name: 'John'}, 3600000); // 1 hour expiry\nconst user = storage.get('user');\n```\n\n### Fallback Pattern\n\n```javascript\nfunction storeData(key, value) {\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (e) {\n    // localStorage might be full or disabled\n    console.warn(\"localStorage failed, falling back to cookie\", e);\n    document.cookie = `${key}=${JSON.stringify(value)};path=/;max-age=31536000`;\n  }\n}\n\nfunction getData(key) {\n  try {\n    const value = localStorage.getItem(key);\n    return value ? JSON.parse(value) : null;\n  } catch (e) {\n    // Try to get from cookie\n    const match = document.cookie.match(new RegExp(`${key}=([^;]+)`));\n    return match ? JSON.parse(match[1]) : null;\n  }\n}\n```\n\nIn modern web development, most applications use a combination of all three storage mechanisms for different purposes, leveraging their unique strengths while being mindful of their limitations and security implications."
    },
    {
      "id": 79,
      "question": "What is the difference between local storage and session storage",
      "answer": "# localStorage vs. sessionStorage\n\nBoth `localStorage` and `sessionStorage` are part of the Web Storage API, providing similar functionality with key differences in data persistence and session handling. Here's a detailed comparison:\n\n## Core Similarities\n\n**1. API and Usage Pattern**\n\nBoth storage types share identical methods and properties:\n\n```javascript\n// Basic operations (identical for both localStorage and sessionStorage)\n\n// Storing data\nstorage.setItem('key', 'value');\nstorage['key'] = 'value';  // Property access syntax\n\n// Retrieving data\nconst value = storage.getItem('key');\nconst value2 = storage['key'];  // Property access syntax\n\n// Checking if a key exists\nif (storage.getItem('key') !== null) { /* exists */ }\n\n// Removing a specific item\nstorage.removeItem('key');\ndelete storage['key'];  // Property access syntax\n\n// Clearing all data\nstorage.clear();\n\n// Getting the number of items\nconst itemCount = storage.length;\n\n// Iterating through all items\nfor (let i = 0; i < storage.length; i++) {\n  const key = storage.key(i);\n  const value = storage.getItem(key);\n  console.log(`${key}: ${value}`);\n}\n\n// Using for...in loop (includes prototype properties, rarely used)\nfor (let key in storage) {\n  if (storage.hasOwnProperty(key)) {\n    console.log(`${key}: ${storage.getItem(key)}`);\n  }\n}\n```\n\n**2. Storage Capacity**\n\nBoth typically offer 5-10MB of storage per origin (exact limit varies by browser).\n\n**3. Storage Scope**\n\nBoth are restricted by the same-origin policy (protocol + hostname + port).\n\n**4. Data Types**\n\nBoth can only store string values, requiring serialization for complex data types:\n\n```javascript\n// Storing objects (works the same in both storage types)\nconst user = { \n  id: 1, \n  name: \"John\",\n  preferences: {\n    theme: \"dark\",\n    fontSize: \"large\"\n  }\n};\n\n// Must serialize objects to store them\nlocalStorage.setItem('user', JSON.stringify(user));\n// or\nsessionStorage.setItem('user', JSON.stringify(user));\n\n// Retrieving and parsing\nconst retrievedUser = JSON.parse(localStorage.getItem('user'));\n// or\nconst sessionUser = JSON.parse(sessionStorage.getItem('user'));\n```\n\n## Key Differences\n\n### 1. Persistence Duration\n\n**localStorage:**\n- Data persists indefinitely until explicitly removed\n- Survives browser restarts and computer reboots\n- Only cleared by JavaScript, clearing browser data, or browser settings\n\n```javascript\n// Data stored here will persist indefinitely\nlocalStorage.setItem('userTheme', 'dark');\nlocalStorage.setItem('hasSeenTutorial', 'true');\n```\n\n**sessionStorage:**\n- Data persists only for the duration of the page session\n- Cleared when the tab/window is closed\n- Not shared between tabs (even of the same origin)\n\n```javascript\n// Data stored here will be gone when tab is closed\nsessionStorage.setItem('currentPageData', JSON.stringify(pageState));\nsessionStorage.setItem('formProgress', '3'); // e.g., step 3 of a wizard\n```\n\n### 2. Session/Tab Isolation\n\n**localStorage:**\n- Shared across all tabs and windows from the same origin\n- Changes in one tab are visible to other tabs immediately (via storage events)\n\n```javascript\n// In tab 1: Set a value\nlocalStorage.setItem('theme', 'dark');\n\n// In tab 2: Can access the same value\nconsole.log(localStorage.getItem('theme')); // \"dark\"\n```\n\n**sessionStorage:**\n- Isolated to the specific tab/window where it was created\n- Each tab has its own independent sessionStorage\n- Even opening the same URL in a new tab creates a fresh sessionStorage\n\n```javascript\n// In tab 1: Set a value\nsessionStorage.setItem('currentFilter', 'newest');\n\n// In tab 2 (same URL): No access to tab 1's data\nconsole.log(sessionStorage.getItem('currentFilter')); // null\n```\n\n### 3. Window/Tab Creation Behavior\n\n**localStorage:**\n- Consistent across all contexts of the same origin\n\n**sessionStorage:**\n- New tabs created via `window.open()` inherit the sessionStorage from the opener\n- Tabs opened via Ctrl+Click or new tab/window do not inherit sessionStorage\n\n```javascript\n// In original tab\nsessionStorage.setItem('sessionData', 'important');\n\n// Open new tab programmatically\nconst newTab = window.open('same-url.html', '_blank');\n// New tab will inherit sessionStorage\n\n// But a manually opened tab will not have this data\n```\n\n### 4. Storage Events\n\n**localStorage:**\n- Changes trigger the storage event in other tabs/windows\n- Allows for cross-tab communication\n\n```javascript\n// In tab 1: Listen for changes made in other tabs\nwindow.addEventListener('storage', (event) => {\n  console.log(`Key changed: ${event.key}`);\n  console.log(`Old value: ${event.oldValue}`);\n  console.log(`New value: ${event.newValue}`);\n  console.log(`Storage area: ${event.storageArea}`);\n  console.log(`URL: ${event.url}`);\n  \n  // Update UI based on changes from other tabs\n  if (event.key === 'userLoggedIn') {\n    updateLoginStatus(event.newValue === 'true');\n  }\n});\n\n// In tab 2: Make a change that triggers the event in tab 1\nlocalStorage.setItem('userLoggedIn', 'true');\n```\n\n**sessionStorage:**\n- Changes do not trigger storage events in other contexts\n- No built-in way to communicate between tabs via sessionStorage\n\n## Use Case Scenarios\n\n### Appropriate for localStorage:\n\n**1. User Preferences**\n```javascript\nlocalStorage.setItem('theme', 'dark');\nlocalStorage.setItem('fontSize', 'large');\nlocalStorage.setItem('sidebarCollapsed', 'true');\n```\n\n**2. Cached Data**\n```javascript\n// Store API responses with expiry time\nfunction cacheApiData(key, data, ttlMinutes = 60) {\n  const item = {\n    value: data,\n    expiry: Date.now() + (ttlMinutes * 60 * 1000)\n  };\n  localStorage.setItem(key, JSON.stringify(item));\n}\n\nfunction getCachedData(key) {\n  const itemStr = localStorage.getItem(key);\n  if (!itemStr) return null;\n  \n  const item = JSON.parse(itemStr);\n  if (Date.now() > item.expiry) {\n    localStorage.removeItem(key);\n    return null;\n  }\n  return item.value;\n}\n```\n\n**3. Offline Application Data**\n```javascript\n// Store data for offline use\nlocalStorage.setItem('offlineArticles', JSON.stringify(articlesData));\nlocalStorage.setItem('lastSyncTimestamp', Date.now().toString());\n```\n\n**4. Authentication Status (non-sensitive)**\n```javascript\n// Store non-sensitive auth info (actual auth should use HttpOnly cookies)\nlocalStorage.setItem('userLoggedIn', 'true');\nlocalStorage.setItem('username', 'johndoe');\nlocalStorage.setItem('lastActive', Date.now().toString());\n```\n\n### Appropriate for sessionStorage:\n\n**1. Form Data During Navigation**\n```javascript\n// Save form progress as user navigates multi-page form\nfunction saveFormProgress(step, formData) {\n  sessionStorage.setItem('formStep', step.toString());\n  sessionStorage.setItem('formData', JSON.stringify(formData));\n}\n\nfunction loadFormProgress() {\n  const step = sessionStorage.getItem('formStep') || '1';\n  const formData = JSON.parse(sessionStorage.getItem('formData') || '{}');\n  return { step: parseInt(step), formData };\n}\n```\n\n**2. Shopping Cart for Current Session**\n```javascript\nfunction addToSessionCart(productId, quantity) {\n  const cart = JSON.parse(sessionStorage.getItem('cart') || '{}');\n  cart[productId] = (cart[productId] || 0) + quantity;\n  sessionStorage.setItem('cart', JSON.stringify(cart));\n}\n```\n\n**3. Wizard/Onboarding Flow State**\n```javascript\n// Track onboarding progress within current session\nsessionStorage.setItem('onboardingStep', '2');\nsessionStorage.setItem('seenFeatures', JSON.stringify(['dashboard', 'profile']));\n```\n\n**4. Tab-Specific UI State**\n```javascript\n// Remember scroll position or UI state just for this tab\nwindow.addEventListener('scroll', () => {\n  sessionStorage.setItem('scrollPosition', window.scrollY.toString());\n});\n\n// On page load\nconst savedScroll = parseInt(sessionStorage.getItem('scrollPosition') || '0');\nif (savedScroll > 0) {\n  window.scrollTo(0, savedScroll);\n}\n```\n\n## Best Practices for Both\n\n**1. Error Handling**\n```javascript\nfunction safelyStoreData(storage, key, value) {\n  try {\n    storage.setItem(key, value);\n    return true;\n  } catch (e) {\n    // Handle QuotaExceededError or other storage errors\n    console.error('Storage failed:', e);\n    if (e.name === 'QuotaExceededError') {\n      alert('Storage full. Please clear some space.');\n      // Possibly clear older items\n    }\n    return false;\n  }\n}\n```\n\n**2. Type Safety**\n```javascript\nfunction storageWrapper(storage) {\n  return {\n    setObject(key, value) {\n      storage.setItem(key, JSON.stringify(value));\n    },\n    getObject(key) {\n      try {\n        return JSON.parse(storage.getItem(key)) || null;\n      } catch (e) {\n        console.error(`Error parsing ${key}:`, e);\n        return null;\n      }\n    },\n    setNumber(key, value) {\n      storage.setItem(key, value.toString());\n    },\n    getNumber(key) {\n      return parseFloat(storage.getItem(key)) || 0;\n    },\n    setBoolean(key, value) {\n      storage.setItem(key, value ? 'true' : 'false');\n    },\n    getBoolean(key) {\n      return storage.getItem(key) === 'true';\n    }\n  };\n}\n\nconst localStore = storageWrapper(localStorage);\nconst sessionStore = storageWrapper(sessionStorage);\n\n// Usage\nlocalStore.setObject('user', {name: 'John', id: 123});\nlocalStore.setBoolean('darkMode', true);\n```\n\nIn summary, while both APIs share the same interface and capabilities, the key distinction is that `localStorage` provides persistent storage across browser sessions, while `sessionStorage` provides temporary storage limited to a single browser tab session."
    },
    {
      "id": 80,
      "question": "What is a promise",
      "answer": "# JavaScript Promises\n\nA **Promise** is an object representing the eventual completion or failure of an asynchronous operation and its resulting value. It's a fundamental building block for handling asynchronous operations in JavaScript.\n\n## Core Concepts\n\n**1. Promise States**\n\nA Promise exists in one of three states:\n- **Pending**: Initial state, neither fulfilled nor rejected\n- **Fulfilled**: The operation completed successfully\n- **Rejected**: The operation failed\n\nOnce a promise is fulfilled or rejected, it becomes **settled** and cannot change states.\n\n**2. Basic Promise Syntax**\n\n```javascript\n// Creating a promise\nconst promise = new Promise((resolve, reject) => {\n  // Asynchronous operation\n  if (/* operation successful */) {\n    resolve(value); // Fulfills the promise with a value\n  } else {\n    reject(reason); // Rejects the promise with a reason (error)\n  }\n});\n\n// Consuming a promise\npromise\n  .then(value => {\n    // Handle success\n  })\n  .catch(error => {\n    // Handle error\n  })\n  .finally(() => {\n    // Execute regardless of success or failure\n  });\n```\n\n## Creating Promises\n\n**Simple Promise Example**\n\n```javascript\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    // Simulate API request\n    setTimeout(() => {\n      if (userId > 0) {\n        const userData = {\n          id: userId,\n          name: 'John Doe',\n          email: 'john@example.com'\n        };\n        resolve(userData); // Success\n      } else {\n        reject(new Error('Invalid user ID')); // Failure\n      }\n    }, 1000);\n  });\n}\n\nfetchUserData(123)\n  .then(user => console.log('User data:', user))\n  .catch(error => console.error('Error:', error.message));\n```\n\n**Converting Callbacks to Promises**\n\n```javascript\n// Traditional callback-based function\nfunction readFileCallback(path, callback) {\n  fs.readFile(path, 'utf8', (error, data) => {\n    if (error) {\n      callback(error, null);\n    } else {\n      callback(null, data);\n    }\n  });\n}\n\n// Converted to Promise-based function\nfunction readFilePromise(path) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, 'utf8', (error, data) => {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(data);\n      }\n    });\n  });\n}\n\n// Using the Promise version\nreadFilePromise('config.json')\n  .then(data => console.log('File contents:', data))\n  .catch(error => console.error('Error reading file:', error));\n```\n\n## Promise Methods\n\n**1. .then()**\n\nHandles the fulfillment (success) of a promise.\n\n```javascript\npromise.then(value => {\n  // Success handler\n  return transformedValue; // Can return a new value\n});\n\n// Can also accept a second argument for rejection handling\npromise.then(\n  value => { /* success */ },\n  reason => { /* rejection */ } // Alternative to .catch()\n);\n```\n\n**2. .catch()**\n\nHandles the rejection (failure) of a promise.\n\n```javascript\npromise.catch(reason => {\n  // Error handling\n  console.error(reason);\n  return recoveryValue; // Can return a recovery value\n});\n```\n\n**3. .finally()**\n\nExecutes code regardless of whether the promise was fulfilled or rejected.\n\n```javascript\npromise\n  .then(value => { /* success */ })\n  .catch(reason => { /* failure */ })\n  .finally(() => {\n    // Always executes\n    // Good for cleanup operations like closing connections\n    // or hiding loading indicators\n  });\n```\n\n## Promise Chaining\n\nPromises can be chained to handle sequences of asynchronous operations.\n\n```javascript\nfetchUserData(123)\n  .then(user => {\n    console.log('Got user:', user);\n    return fetchUserPosts(user.id); // Return a new promise\n  })\n  .then(posts => {\n    console.log('User posts:', posts);\n    return fetchPostComments(posts[0].id); // Return another promise\n  })\n  .then(comments => {\n    console.log('Post comments:', comments);\n  })\n  .catch(error => {\n    // Handles errors from any step in the chain\n    console.error('Error in promise chain:', error);\n  });\n```\n\n## Static Promise Methods\n\n**1. Promise.resolve()**\n\nCreates a promise that is resolved with a given value.\n\n```javascript\n// Creates an already resolved promise\nconst resolvedPromise = Promise.resolve('Already resolved');\n\nresolvedPromise.then(value => console.log(value)); // \"Already resolved\"\n\n// Useful for conditional promise creation\nfunction getData(useCache) {\n  if (useCache && cache.has('data')) {\n    return Promise.resolve(cache.get('data'));\n  }\n  return fetchFromAPI();\n}\n```\n\n**2. Promise.reject()**\n\nCreates a promise that is rejected with a given reason.\n\n```javascript\nconst rejectedPromise = Promise.reject(new Error('Something went wrong'));\n\nrejectedPromise.catch(error => console.error(error.message)); // \"Something went wrong\"\n```\n\n**3. Promise.all()**\n\nWaits for all promises to resolve, or rejects if any promise rejects.\n\n```javascript\nconst promise1 = fetchUserProfile(123);\nconst promise2 = fetchUserPosts(123);\nconst promise3 = fetchUserFollowers(123);\n\nPromise.all([promise1, promise2, promise3])\n  .then(([profile, posts, followers]) => {\n    console.log('Profile:', profile);\n    console.log('Posts:', posts);\n    console.log('Followers:', followers);\n  })\n  .catch(error => {\n    // If ANY promise rejects, this executes\n    console.error('An error occurred:', error);\n  });\n```\n\n**4. Promise.race()**\n\nSettles as soon as any promise settles (resolves or rejects).\n\n```javascript\nconst dataPromise = fetchData(); // Might take a while\nconst timeoutPromise = new Promise((_, reject) => {\n  setTimeout(() => reject(new Error('Request timed out')), 5000);\n});\n\nPromise.race([dataPromise, timeoutPromise])\n  .then(data => console.log('Data received:', data))\n  .catch(error => console.error('Error:', error.message));\n```\n\n**5. Promise.allSettled() (ES2020)**\n\nWaits for all promises to settle regardless of whether they fulfill or reject.\n\n```javascript\nconst promises = [\n  fetch('/api/users/1'),\n  fetch('/api/users/2'),\n  fetch('/api/users/3')\n];\n\nPromise.allSettled(promises)\n  .then(results => {\n    results.forEach((result, index) => {\n      if (result.status === 'fulfilled') {\n        console.log(`Promise ${index} fulfilled with:`, result.value);\n      } else {\n        console.log(`Promise ${index} rejected with:`, result.reason);\n      }\n    });\n  });\n```\n\n**6. Promise.any() (ES2021)**\n\nSettles as soon as any promise fulfills, or rejects if all promises reject.\n\n```javascript\nconst serverPromises = [\n  fetch('https://api1.example.com/data'),\n  fetch('https://api2.example.com/data'),\n  fetch('https://api3.example.com/data')\n];\n\nPromise.any(serverPromises)\n  .then(response => {\n    console.log('Got a successful response from one server');\n    return response.json();\n  })\n  .catch(error => {\n    // AggregateError: All promises were rejected\n    console.error('All servers failed:', error);\n  });\n```\n\n## Common Promise Patterns\n\n**1. Timeout Pattern**\n\n```javascript\nfunction fetchWithTimeout(url, timeout = 5000) {\n  return Promise.race([\n    fetch(url),\n    new Promise((_, reject) => {\n      setTimeout(() => reject(new Error('Request timed out')), timeout);\n    })\n  ]);\n}\n\nfetchWithTimeout('https://api.example.com/data', 3000)\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error.message));\n```\n\n**2. Retry Pattern**\n\n```javascript\nasync function fetchWithRetry(url, retries = 3, delay = 1000) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fetch(url);\n    } catch (error) {\n      if (i === retries - 1) throw error;\n      console.log(`Attempt ${i + 1} failed, retrying in ${delay}ms...`);\n      await new Promise(resolve => setTimeout(resolve, delay));\n      delay *= 2; // Exponential backoff\n    }\n  }\n}\n```\n\n**3. Sequential Execution**\n\n```javascript\nasync function processSequentially(items, asyncFunction) {\n  const results = [];\n  \n  for (const item of items) {\n    const result = await asyncFunction(item);\n    results.push(result);\n  }\n  \n  return results;\n}\n\n// Usage\nprocessSequentially([1, 2, 3], async (num) => {\n  const response = await fetch(`/api/data/${num}`);\n  return response.json();\n});\n```\n\n**4. Concurrent with Limit**\n\n```javascript\nasync function processConcurrentWithLimit(items, asyncFunction, concurrency = 3) {\n  const results = [];\n  const executing = [];\n  \n  for (const item of items) {\n    const p = Promise.resolve().then(() => asyncFunction(item));\n    results.push(p);\n    \n    if (concurrency <= items.length) {\n      const e = p.then(() => executing.splice(executing.indexOf(e), 1));\n      executing.push(e);\n      if (executing.length >= concurrency) {\n        await Promise.race(executing);\n      }\n    }\n  }\n  \n  return Promise.all(results);\n}\n```\n\n## Error Handling in Promises\n\n**1. Catching Errors in Chains**\n\n```javascript\nfetchUserData(123)\n  .then(user => {\n    // This might throw an error\n    const formattedData = formatUserData(user);\n    return formattedData;\n  })\n  .then(formattedData => {\n    return saveUserData(formattedData);\n  })\n  .catch(error => {\n    // Catches errors from any previous step\n    console.error('Error in promise chain:', error);\n    \n    // Return a default value to continue the chain\n    return { default: true, name: 'Unknown User' };\n  })\n  .then(result => {\n    // This runs with either the real result or the default\n    console.log('Final result:', result);\n  });\n```\n\n**2. Avoiding Unhandled Promise Rejections**\n\n```javascript\n// Global handler for uncaught promise rejections\nwindow.addEventListener('unhandledrejection', event => {\n  console.error('Unhandled promise rejection:', event.reason);\n  // Prevent the default handler\n  event.preventDefault();\n});\n```\n\nPromises provide a cleaner and more maintainable way to handle asynchronous operations compared to callbacks, particularly for complex sequences of operations or error handling scenarios."
    }
  ]
}